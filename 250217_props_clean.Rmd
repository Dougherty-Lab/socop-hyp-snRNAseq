---
title: "Analysis of proportion differences in MYT1L tuberal hypothalamus after social operant conditioning"
author: "Simona Sarafinovska"
date: "2025-02-18"
---

# Set up environment
```{r dependencies, warning=FALSE, message=FALSE}
# Change this to your directory
.libPaths('/ref/jdlab/software/r-envs/simona/r-packages/4.2/')

# Load dependencies
library(dplyr)
library(Seurat)
library(patchwork)
library(Matrix)
library(ggplot2)
library(cowplot)
library(RColorBrewer)
library(scCustomize)
library(patchwork)
library(qs)
library(viridis)
library(ggpubr)
library(SeuratDisk)
library(SeuratWrappers)
library(ComplexHeatmap)
library(stringr)
library(clustree)
library(ggrastr)
library(monocle3)
library(randomcoloR)
library(DoubletFinder)
library(parallel)
library(ggtree)
library(AnnotationDbi)
library(org.Mm.eg.db)
library(anndata)
#library(magick)
library(speckle)
library(limma)
library(edgeR)
library(pheatmap)
library(gt)
library(data.table)
library(biomaRt)
library(ggVennDiagram)
library(VennDiagram)
library(corrplot)
library(tidyr)


set.seed(420)

source("color_utils.R")
```


# Load in preprocessed data

```{r load in data}
combined.neuronal <- readRDS("./SocOp_MYT1L_snRNAseq_SS19_240328/output/240723_combined.neuronal_1-5_5pct.rds")
combined.neuronal
```


```{r metadata formatting}
combined.neuronal@meta.data$sample <- as.factor(gsub("-", "_", combined.neuronal@meta.data$sample))

# Saving scatterplots won't work if you have "/" in cluster name
combined.neuronal@meta.data$cell_type <- as.factor(gsub("/", "-", combined.neuronal@meta.data$cell_type))
```

# Props by ...

```{r make proportions df}
celldistribution <- data.frame(table(combined.neuronal@meta.data$cell_type, combined.neuronal@meta.data$sample))
colnames(celldistribution) <- c('Cluster', 'Sample', 'Number')
celldistribution$Sex <- gsub('.*_(\\w)_.*', '\\1', celldistribution$Sample)
celldistribution$Genotype <- gsub('^(.*?)_.*$', '\\1', celldistribution$Sample)

celldistribution <- celldistribution %>%
  group_by(Sample) %>%
  mutate(norm_count = Number / sum(Number)) %>%
  ungroup()

celldistribution$Genotype <- factor(celldistribution$Genotype, levels = c('Het', 'WT'))
celldistribution$Sex <- factor(celldistribution$Sex, levels = c('M', 'F'))

celldistribution
```

## by genotype. 
First let's look at a UMAP and PCA plot. 
```{r umap by sex}
DimPlot_scCustom(combined.neuronal,
                 colors_use = palette_geno,
                 group.by = 'genotype',
                 reduction = 'umap',
                 label = FALSE,
                 raster = FALSE,
                 split_seurat = TRUE,
                 pt.size = 0.01) +
  theme(legend.position = 'right')

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/240531_umap_1-5_5pct_res1.8_50dims_neuronal_bygeno.png",
        width = 12,
        height = 12,
        dpi = 300)
```
```{r pca by sex}
DimPlot_scCustom(combined.neuronal,
                 colors_use = palette_geno,
                 group.by = 'genotype',
                 reduction = 'pca',
                 label = FALSE,
                 raster = FALSE,
                 split_seurat = TRUE,
                 pt.size = 0.01) +
  theme(legend.position = 'right')

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/240531_pca_1-5_5pct_res1.8_50dims_neuronal_bygeno.png",
        width = 12,
        height = 12,
        dpi = 300)
```

mean_norm_count is the mean of the normalized counts per cluster for each genotype (so it's the same for WT_M_1 through WT_F_3), se_mean is the SE of that mean. 
norm_count_normalized is the norm_count (abundance of this cluster relative to other clusters for each sample) divided by the mean_norm_count (abundance averaged across genotype). 

```{r df with prop means by geno}
calcnums <- celldistribution %>%
  group_by(Cluster, Genotype) %>%
  mutate(mean_norm_count = mean(norm_count)) %>%
  mutate(se_mean = sd(norm_count)/sqrt(36)) %>%
  drop_na()

mean_norm_count_WT_M1 <- calcnums$mean_norm_count[calcnums$Sample == "WT_M_1"]
calcnums$mean_norm_count_WT <- mean_norm_count_WT_M1[match(calcnums$Cluster, calcnums$Cluster)]

calcnums <- calcnums %>%
  mutate(norm_count_normalizedtoWT = ((norm_count / mean_norm_count_WT) - 1)) %>%
  drop_na()

# Make sure the WT mean is around 0
calcnums %>%
  filter(Genotype == "WT") %>%
  group_by(Cluster) %>%
  summarize(mean = mean(norm_count_normalizedtoWT))

calcnums <- calcnums %>%
  group_by(Cluster, Genotype) %>%
  mutate(mean_norm_count_normalizedtoWT = mean(norm_count_normalizedtoWT)) %>%
  mutate(se_mean_norm_count_normalizedtoWT = sd(norm_count_normalizedtoWT)/sqrt(36)) %>%
  drop_na()

calcnums <- calcnums %>%
  group_by(Cluster, Genotype) %>%
  mutate(mean_normtoWT_pct = mean_norm_count_normalizedtoWT * 100) %>%
  mutate(se_mean_normtoWT_pct = se_mean_norm_count_normalizedtoWT * 100) %>%
  drop_na()

calcnums$Genotype <- factor(calcnums$Genotype, levels = c('Het', 'WT'))

cluster_order <- rev(sort(levels(combined.neuronal)))

calcnums$Cluster <- factor(calcnums$Cluster, levels = cluster_order)
#celldistribution$Cluster <- factor(calcnums$Cluster, levels = cluster_order)
```

```{r bar plots props by geno}
p1 <- ggplot(calcnums, aes(x = mean_norm_count, y = Cluster, fill = Genotype)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
             color = "black",
             size = 0.01) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "Cluster") +
  theme_classic() +
  scale_fill_manual(values = palette_geno) +
  theme(legend.position = "none", 
        axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                             length.out = length(unique(calcnums$Cluster)))))



p2 <- ggplot(calcnums, aes(x = mean_norm_count_normalizedtoWT, y = Cluster, fill = Genotype)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
             color = "black",
             size = 0.01) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count_normalizedtoWT - se_mean_norm_count_normalizedtoWT, xmax = mean_norm_count_normalizedtoWT + se_mean_norm_count_normalizedtoWT),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_geno) +
  theme(axis.text.y = element_blank(),
        legend.position = "none")

p4 <- ggplot(calcnums, aes(x = mean_normtoWT_pct, y = Cluster, fill = Genotype)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
             color = "black",
             size = 0.01) +
  geom_errorbar(aes(y = Cluster, xmin = mean_normtoWT_pct - se_mean_normtoWT_pct, xmax = mean_normtoWT_pct + se_mean_normtoWT_pct),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Percent change in proportion", y = "") +
  theme_classic() +
  theme(axis.text.y = element_blank()) +
  scale_fill_manual(values = palette_geno)

wrap_plots(p1, p2, p4)
ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250217_proportionsbyGeno_1-5_5pct_res1.8_50dims_neuronal.png',
       device = png,
       width = 12,
       height = 8)
```

```{r propeller genotype}
props.geno <- propeller(clusters = combined.neuronal@meta.data$cell_type, sample = combined.neuronal$sample, group = combined.neuronal$genotype, transform = "logit")

write.csv(props.geno, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_props_Geno_1-5_5pct_res1.8_50dims_neuronal.csv", row.names = TRUE)
props.geno
```

#### adding cells and genes to plot
```{r selecting sig clusters from DEG analysis}
significant_cluster_names <- c("RT-ZI Gnb3 Gaba_2", "STR D1 Gaba","TH Prkcd Grin2c Glut_2", "TH Prkcd Grin2c Glut_3", "TH Prkcd Grin2c Glut_4", "TH Sema5b-Ntrk Glut")

sig_calcnums <- calcnums %>%
  dplyr::filter(Cluster %in% significant_cluster_names) %>%
  arrange(match(Cluster, significant_cluster_names))

sig_calcnums$Cluster <- factor(sig_calcnums$Cluster, levels = rev(significant_cluster_names))
```

```{r bar plot sig clusters only}
sig_p1 <- ggplot(sig_calcnums, aes(x = mean_norm_count, y = Cluster, fill = Genotype)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  geom_point(aes(x = norm_count, y = Cluster),
             position = position_dodge(width = 0.7),
             color = "black",
             size = 0.01) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_geno) +
  theme(legend.position = "none", axis.text.y = element_blank())

sig_p1
```

```{r cell and gene numbers df}
cluster.set <- rev(levels(Idents(combined.neuronal)))

cells.per.cluster <- c(table(combined.neuronal$cell_type)[as.character(cluster.set)])
counts <- GetAssayData(combined.neuronal, assay = "RNA", slot = "counts")
cell_idents <- Idents(combined.neuronal)

# Function to count unique genes for a set of cells
count_unique_genes <- function(cell_indices) {
  sum(rowSums(counts[, cell_indices, drop = FALSE]) > 0)
}

# Get unique genes per cluster
genes.per.cluster <- sapply(levels(cell_idents), function(ident) {
  cells_in_cluster <- which(cell_idents == ident)
  count_unique_genes(cells_in_cluster)
})

# Name the results with cluster identities
names(genes.per.cluster) <- levels(cell_idents)

cellsgenes_df <- data.frame(Cluster = cluster.set,
CellsPerCluster = cells.per.cluster,
GenesPerCluster = genes.per.cluster)
```

```{r cell and genes plot sig only }
# Create a data frame for the significant clusters
sig_cellsgenes_df <- cellsgenes_df %>%
  dplyr::filter(Cluster %in% significant_cluster_names) %>%
  arrange(match(Cluster, significant_cluster_names))

# Ensure Cluster is a factor with levels in the correct order
sig_cellsgenes_df$Cluster <- factor(sig_cellsgenes_df$Cluster, levels = rev(significant_cluster_names))

cells <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = CellsPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = CellsPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 2000) +
  ylab("") +
  xlab("Nuclei") +
  theme_classic() +
  scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(axis.text.x = element_blank(),
        legend.position = "none",
        axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                             length.out = length(unique(calcnums$Cluster)))))

genes <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = GenesPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = GenesPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 19000) +
  ylab("") +
  xlab("Genes") +
  theme_classic() +
    scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none")

cells
genes
```

```{r save wrapped plots geno}
wrap_plots(cells, genes, sig_p1, nrow = 1)

ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250211_propsbyGeno_sigonly.pdf',
       device = pdf,
       width = 20,
       height = 4)
```

### props diff. by region
```{r add region to props df geno}
anatomical_dict <- c(
  "TH Prkcd Grin2c Glut_1" = "Other",
  "TH Prkcd Grin2c Glut_2" = "Other",
  "TH Prkcd Grin2c Glut_3" = "Other",
  "TH Prkcd Grin2c Glut_4" = "Other",
  "AV Col27a1 Glut" = "Other",
  "TH Prkcd Grin2c Glut_5" = "Other",
  "TH Prkcd Grin2c Glut_6" = "Other",
  "TH Prkcd Grin2c Glut_7" = "Other",
  "RE-Xi Nox4 Glut" = "Other",
  "TH-PVT-RE Ntrk1-Nox4 Glut" = "Other",
  "TH Sema5b-Ntrk Glut" = "Other",
  "AD Serpinb7 Glut" = "Other",
  "HY NSCs_1" = "Hypothalamus",
  "Chat GABA" = "Hypothalamus",
  "STR-PAL Chst9 Gaba" = "Other",
  "Mixed" = "Hypothalamus",
  "VMH Nr5a1 Glut_1" = "Hypothalamus",
  "Lhx6/Lhx8 Gaba" = "Hypothalamus",
  "Lhx6 Gaba" = "Hypothalamus",
  "PH-LHA-MM Foxb1 Glut" = "Hypothalamus",
  "PV-PT Ntrk1/Sp9 Glut" = "Other",
  "MEA Glut" = "Hypothalamus",
  "COAa-PAA-MEA Barhl2 Glut" = "Hypothalamus",
  "VMH Nr5a1 Glut_2" = "Hypothalamus",
  "DMH Hmx2/Vgll1 Glut" = "Hypothalamus",
  "TU-ARH Otp Six6 Gaba" = "Hypothalamus",
  "DMH Gaba" = "Hypothalamus",
  "ZI/PVH/SBPV Pax6/Prox1 Gaba" = "Other",
  "AHN Onecut3 Gaba" = "Hypothalamus",
  "AHN-PVHd-PVR Mixed Gaba" = "Hypothalamus",
  "PVpo-VMPO-MPN Hmx2 Gaba" = "Hypothalamus",
  "CEA-BST Meis2 Gaba" = "Hypothalamus",
  "MEA-BST Mixed Gaba" = "Hypothalamus",
  "LHA Pmch Glut" = "Hypothalamus",
  "Pitx2 Glut" = "Hypothalamus",
  "Trh Glut" = "Hypothalamus",
  "PH-LHA-PVH-SO-PVa Nxph4 Glut" = "Hypothalamus",
  "RT-ZI Gnb3 Gaba_1" = "Other",
  "GPi Tbr1 Cngb3 Gaba-Glut" = "Other",
  "SI-MA-LPO-LHA Skor1 Glut" = "Hypothalamus",
  "ADP-MPO Trp73 Glut" = "Hypothalamus",
  "SCsg Gabrr2 Gaba" = "Other",
  "ZI Mixed Gaba" = "Other",
  "ZI Pax6 Gaba" = "Other",
  "GPe-SI Sox6 Cyp26b1 Gaba" = "Other",
  "NDB-SI-MA-STRv Lhx8 Gaba" = "Hypothalamus",
  "SI-MPO-LPO-ADP Lhx8 Gaba" = "Hypothalamus",
  "HY NSCs_2" = "Hypothalamus",
  "STR D1/D2 Gaba" = "Other",
  "STR D1 Gaba" = "Other",
  "MEA Slc17a7 Glut" = "Hypothalamus",
  "ARC Mixed Glut" = "Hypothalamus",
  "PVN Mixed Glut" = "Hypothalamus",
  "PF Fzd5 Glut" = "Other",
  "LH-MH Glut" = "Hypothalamus",
  "STN-PSTN Pitx2 Glut" = "Other",
  "SNc-VTA-RAmb Foxa1 Dopa" = "Other",
  "RT-ZI Gnb3 Gaba_2" = "Other",
  "PVH-SO-PVa Avp Glut" = "Hypothalamus",
  "PVH-SO-PVa Agtr1a Glut" = "Hypothalamus",
  "TRS-BAC Sln Glut" = "Hypothalamus",
  "Hist Gaba" = "Hypothalamus",
  "Mixed Meis2 Gaba" = "Hypothalamus",
  "TH Prkcd Grin2c" = "Other",
  "SCH Six6 Cdc14a Gaba" = "Hypothalamus"
)
props.geno$region <- anatomical_dict[props.geno$BaselineProp.clusters]
props.geno<- props.geno %>%
  dplyr::arrange(region, P.Value)
props.geno <- props.geno[order(props.geno$region, props.geno$P.Value, decreasing = TRUE), ]
```

```{r p-values by region plot geno}
n_clusters <- length(unique(props.geno$BaselineProp.clusters))
text_colors <- rep(c("#000000", "#555555"), length.out = n_clusters)

ggplot(props.geno, aes(x = -log10(P.Value), 
                      y = factor(BaselineProp.clusters, 
                               levels = unique(props.geno$BaselineProp.clusters)), 
                      color = region)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(x = "-log10(P-value)",
       y = "Cluster",
       title = "Genotype differences in cluster proportions") +
  theme(
    axis.text.y = element_text(size = 8,
                              color = rev(text_colors)),  # rev() to match the order of clusters
    legend.position = "right"
  )

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250211_genodiff_pvalues_hypovother.pdf",
        width = 12,
        height = 12,
        dpi = 300)
```



## by sex. 
First let's look at the UMAP and PCA:
```{r umap by sex}
DimPlot_scCustom(combined.neuronal,
                 colors_use = palette_sex,
                 group.by = 'sex',
                 reduction = 'umap',
                 label = FALSE,
                 raster = FALSE,
                 split_seurat = TRUE,
                 pt.size = 0.01) +
  theme(legend.position = 'right')

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250212_umap_1-5_5pct_res1.8_50dims_neuronal_bysex.png",
        width = 12,
        height = 12,
        dpi = 300)
```

```{r pca by sex}
DimPlot_scCustom(combined.neuronal,
                 colors_use = palette_sex,
                 group.by = 'sex',
                 reduction = 'pca',
                 label = FALSE,
                 raster = FALSE,
                 split_seurat = TRUE,
                 pt.size = 0.01) +
  theme(legend.position = 'right')

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250212_pca_1-5_5pct_res1.8_50dims_neuronal_bysex.png",
        width = 12,
        height = 12,
        dpi = 300)
```

```{r df with prop means by sex}
calcnums <- celldistribution %>%
  group_by(Cluster, Sex) %>%
  mutate(mean_norm_count = mean(norm_count)) %>%
  mutate(se_mean = sd(norm_count)/sqrt(36)) %>%
  drop_na()

mean_norm_count_M_M1 <- calcnums$mean_norm_count[calcnums$Sample == "WT_M_1"]
calcnums$mean_norm_count_M <- mean_norm_count_M_M1[match(calcnums$Cluster, calcnums$Cluster)]

calcnums <- calcnums %>%
  mutate(norm_count_normalizedtoM = ((norm_count / mean_norm_count_M) - 1)) %>%
  drop_na()

# Make sure the WT mean is around 0
calcnums %>%
  filter(Sex == "M") %>%
  group_by(Cluster) %>%
  summarize(mean = mean(norm_count_normalizedtoM))

calcnums <- calcnums %>%
  group_by(Cluster, Sex) %>%
  mutate(mean_norm_count_normalizedtoM = mean(norm_count_normalizedtoM)) %>%
  mutate(se_mean_norm_count_normalizedtoM = sd(norm_count_normalizedtoM)/sqrt(36)) %>%
  drop_na()

calcnums <- calcnums %>%
  group_by(Cluster, Sex) %>%
  mutate(mean_normtoM_pct = mean_norm_count_normalizedtoM * 100) %>%
  mutate(se_mean_normtoM_pct = se_mean_norm_count_normalizedtoM * 100) %>%
  drop_na()

cluster_order <- rev(sort(levels(combined.neuronal)))
calcnums$Sex <- factor(calcnums$Sex, levels = c('M', 'F'))
```

```{r bar plot props by sex}
p1 <- ggplot(calcnums, aes(x = mean_norm_count, y = Cluster, fill = Sex)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "Cluster") +
  theme_classic() +
  scale_fill_manual(values = palette_sex) +
  scale_x_continuous(limits = c(0, 0.05)) +
   theme(legend.position = "none",
        axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                             length.out = length(unique(calcnums$Cluster)))))


p2 <- ggplot(calcnums, aes(x = mean_norm_count_normalizedtoM, y = Cluster, fill = Sex)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count_normalizedtoM - se_mean_norm_count_normalizedtoM, xmax = mean_norm_count_normalizedtoM + se_mean_norm_count_normalizedtoM),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_sex) +
  theme(axis.text.y = element_blank(),
        legend.position = "none")


p4 <- ggplot(calcnums, aes(x = mean_normtoM_pct, y = Cluster, fill = Sex)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_errorbar(aes(y = Cluster, xmin = mean_normtoM_pct - se_mean_normtoM_pct, xmax = mean_normtoM_pct + se_mean_normtoM_pct),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Percent change in proportion") +
  theme_classic() +
  scale_fill_manual(values = palette_sex) +
  theme(axis.text.y = element_blank(),
        legend.position = "right")


wrap_plots(p1, p2, p4)
ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250217_proportionsbySex_1-5_5pct_res1.8_50dims_neuronal.png',
       device = png,
       width = 12,
       height = 8)
```

```{r propeller by sex}
props.sex <- propeller(clusters = combined.neuronal@meta.data$cell_type, sample = combined.neuronal$sample, group = combined.neuronal$sex, transform = "logit")

# write.csv(props.sex, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_props_Sex_1-5_5pct_res1.8_50dims_neuronal.csv", row.names = TRUE)
props.sex
```


#### adding cells and genes to plot
```{r selecting sig clusters from props analysis}
# Filter the data frame for P.Value < 0.051
significant_clusters <- props.sex[props.sex$P.Value < 0.051, ]

# Extract the BaselineProp.clusters for the significant results
significant_cluster_names <-sort(as.character(significant_clusters$BaselineProp.clusters))

# Print the list of significant clusters
print(significant_cluster_names)
```

```{r cells and genes plot for sig clusters sex}
# Create a data frame for the significant clusters
sig_cellsgenes_df <- cellsgenes_df %>%
  dplyr::filter(Cluster %in% significant_cluster_names) %>%
  arrange(match(Cluster, significant_cluster_names))

# Ensure Cluster is a factor with levels in the correct order
sig_cellsgenes_df$Cluster <- factor(sig_cellsgenes_df$Cluster, levels = rev(significant_cluster_names))

cells <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = CellsPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = CellsPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 2000) +
  ylab("") +
  xlab("Nuclei") +
  theme_classic() +
  scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(axis.text.x = element_blank(),
        legend.position = "none",
        axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                             length.out = length(unique(calcnums$Cluster)))))

genes <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = GenesPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = GenesPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 19000) +
  ylab("") +
  xlab("Genes") +
  theme_classic() +
    scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none")

wrap_plots(cells,genes)
```

```{r bar plot sig clusters only sex}
sig_calcnums <- calcnums %>%
  dplyr::filter(Cluster %in% significant_cluster_names) %>%
  arrange(match(Cluster, significant_cluster_names))


sig_calcnums$Cluster <- factor(sig_calcnums$Cluster, levels = rev(significant_cluster_names))

sig_p1 <- ggplot(sig_calcnums, aes(x = mean_norm_count, y = Cluster, fill = Sex)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
 geom_point(aes(x = norm_count, y = Cluster),
             position = position_dodge(width = 0.7),
             color = "black",
             size = 0.01) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_sex) +
  scale_x_continuous(limits = c(0, 0.05)) +
   theme(legend.position = "right", 
         axis.text.y = element_blank())

sig_p1
```

```{r save wrapped plots sex}
wrap_plots(cells, genes, sig_p1, nrow = 1)

ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250217_propsandDEGsbySex_sigonly.pdf',
       device = pdf,
       width = 20,
       height = 4)
```

### props diff. by Region
```{r add region to props df sex}
props.sex$region <- anatomical_dict[props.sex$BaselineProp.clusters]
props.sex<- props.sex %>%
  dplyr::arrange(region, P.Value)
props.sex <- props.sex[order(props.sex$region, props.sex$P.Value, decreasing = TRUE), ]
```

```{r p-values by region plot sex}
n_clusters <- length(unique(props.sex$BaselineProp.clusters))
text_colors <- rep(c("#000000", "#555555"), length.out = n_clusters)

ggplot(props.sex, aes(x = -log10(P.Value), 
                      y = factor(BaselineProp.clusters, 
                               levels = unique(props.sex$BaselineProp.clusters)), 
                      color = region)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(x = "-log10(P-value)",
       y = "Cluster",
       title = "Sex differences in cluster proportions") +
  theme(
    axis.text.y = element_text(size = 8,
                              color = rev(text_colors)),  # rev() to match the order of clusters
    legend.position = "right"
  )

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250217_sexdiff_pvalues_hypovother.pdf",
        width = 12,
        height = 12,
        dpi = 300)
```

```{r p-values by region plot sex top 10}
filtered_props <- props.sex %>%
  group_by(region) %>%
  arrange(P.Value) %>%
  slice_head(n = 10) %>%
  ungroup() %>%
  arrange(rev(region))

# Then use the filtered data in your plot
ggplot(filtered_props, aes(x = -log10(P.Value), 
                          y = factor(BaselineProp.clusters, 
                                   levels = unique(filtered_props$BaselineProp.clusters)), 
                          color = region)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(x = "-log10(P-value)",
       y = "Cluster",
       title = "Sex differences in cluster proportions") +
  theme(
    axis.text.y = element_text(size = 8,
                              color = rev(text_colors)[1:nrow(filtered_props)]),  # adjust colors to match filtered data
    legend.position = "right",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.line.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),  
    axis.ticks.y = element_line(color = "black")
    )
  

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250217_sexdiff_pvalues_hypovother.pdf",
        width = 8,
        height = 12,
        dpi = 300)
```

```{r Fisher's for props significance by region}
# Create contingency table of significant vs non-significant clusters by region
props.sex$significant <- props.sex$P.Value < 0.05

# Create contingency table
cont_table <- with(props.sex, table(region, significant))

# Print the contingency table
print("Number of clusters by region and significance:")
print(cont_table)

# Run Fisher's exact test
fisher_result <- fisher.test(cont_table)

# Print results
print("\nFisher's exact test results:")
print(fisher_result)

# Calculate and print percentages for easier interpretation
percentages <- prop.table(cont_table, margin = 1) * 100  # margin=1 calculates percentages within each region
print("\nPercentage of significant clusters by region:")
print(percentages[,"TRUE"])
```

## by dissector
Since two people were dissecting the brains, we want to compare to see if 
proportions differ by dissector. 
```{r load in dissector data}
dissector_data <- read.csv("./SocOp_MYT1L_snRNAseq_SS19_240328/output/073123_Dissector_forR.csv", stringsAsFactors = FALSE)
dissector_data <- dissector_data[,apply(dissector_data, 2, function(x) { sum(!is.na(x)) > 0 })]
dissector_data <- subset(dissector_data, select = -c(Sac_Learner, Ever_Learner, Coded_ID))
head(dissector_data)
```

```{r add dissector to metadata}
# Merge the metadata with behavior_data
metadata <- merge(combined.neuronal@meta.data, dissector_data, by = "sample", all.x = TRUE, sort = FALSE)

# Set the rownames of the merged metadata to the preserved rownames
rownames(metadata) <- rownames(combined.neuronal@meta.data) 

dim(metadata)
dim(combined.neuronal@meta.data)

combined.neuronal@meta.data <- metadata

combined.neuronal$Dissector <- factor(combined.neuronal$Dissector)
levels(combined.neuronal$Dissector) <- c("Din", "Simona")
```

First let's plot UMAPs and PCAs. 
```{r umap by dissector}
DimPlot_scCustom(combined.neuronal,
                 colors_use = palette_dissector,
                 group.by = "Dissector",
                 reduction = 'umap',
                 label = FALSE,
                 raster = FALSE,
                 split_seurat = TRUE,
                 pt.size = 0.01) +
  theme(legend.position = 'right')

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250217_umap_neuronal_bydissector.png",
        width = 12,
        height = 12,
        dpi = 300)
 
  ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250217_umap_neuronal_bydissector.pdf",
        width = 12,
        height = 12,
        dpi = 300)
```

```{r pca by dissector}
DimPlot_scCustom(combined.neuronal,
                 colors_use = palette_dissector,
                 group.by = 'Dissector',
                 reduction = 'pca',
                 label = FALSE,
                 raster = FALSE,
                 split_seurat = TRUE,
                 pt.size = 0.01) +
  theme(legend.position = 'right')


 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250217_pca_neuronal_bydissector.png",
        width = 12,
        height = 12,
        dpi = 300)
 
  ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250217_pca_neuronal_bydissector.pdf",
        width = 12,
        height = 12,
        dpi = 300)
```
```{r load in dissector df}
dissector_data <- read.csv("./SocOp_MYT1L_snRNAseq_SS19_240328/output/073123_Dissector_forR.csv", stringsAsFactors = FALSE)
dissector_data <- dissector_data[,apply(dissector_data, 2, function(x) { sum(!is.na(x)) > 0 })]
dissector_data <- subset(dissector_data, select = -c(Sac_Learner, Ever_Learner, Coded_ID))
head(dissector_data)
```

```{r proprotions df with dissector}
celldistribution <- data.frame(table(combined.neuronal@meta.data$cell_type, combined.neuronal@meta.data$sample))
colnames(celldistribution) <- c('Cluster', 'Sample', 'Number')
celldistribution$Sex <- gsub('.*_(\\w)_.*', '\\1', celldistribution$Sample)
celldistribution$Genotype <- gsub('^(.*?)_.*$', '\\1', celldistribution$Sample)

celldistribution <- left_join(celldistribution,
                             dissector_data[, c("sample", "Dissector")],
                             by = c("Sample" = "sample"))

celldistribution <- celldistribution %>%
  group_by(Sample) %>%
  mutate(norm_count = Number / sum(Number)) %>%
  ungroup()


celldistribution$Dissector <- factor(celldistribution$Dissector, levels = c('Din', 'Simona'))

celldistribution
```


```{r df with prop means by dissector}
calcnums <- celldistribution %>%
  group_by(Cluster, Dissector) %>%
  mutate(mean_norm_count = mean(norm_count)) %>%
  mutate(se_mean = sd(norm_count)/sqrt(36)) %>%
  drop_na()

mean_norm_count_WT_M1 <- calcnums$mean_norm_count[calcnums$Sample == "WT_M_1"]
calcnums$mean_norm_count_WT <- mean_norm_count_WT_M1[match(calcnums$Cluster, calcnums$Cluster)]

calcnums <- calcnums %>%
  mutate(norm_count_normalizedtoNL = ((norm_count / mean_norm_count_WT) - 1)) %>%
  drop_na()

# Make sure the WT mean is around 0
calcnums %>%
  filter(Dissector == "Din") %>%
  group_by(Cluster) %>%
  summarize(mean = mean(norm_count_normalizedtoNL))

calcnums <- calcnums %>%
  group_by(Cluster, Dissector) %>%
  mutate(mean_norm_count_normalizedtoNL = mean(norm_count_normalizedtoNL)) %>%
  mutate(se_mean_norm_count_normalizedtoNL = sd(norm_count_normalizedtoNL)/sqrt(36)) %>%
  drop_na()

calcnums <- calcnums %>%
  group_by(Cluster, Dissector) %>%
  mutate(mean_normtoNL_pct = mean_norm_count_normalizedtoNL * 100) %>%
  mutate(se_mean_normtoNL_pct = se_mean_norm_count_normalizedtoNL * 100) %>%
  drop_na() %>%
  ungroup()

calcnums$Dissector <- factor(calcnums$Dissector, levels = c('Din', 'Simona'))
calcnums
```

```{r bar plots props by dissector}
cluster_order <- sort(as.character(unique(calcnums$Cluster), decreasing = TRUE))

p1 <- ggplot(calcnums, aes(x = mean_norm_count, 
                           y = factor(Cluster, levels = rev(cluster_order)), 
                           fill = Dissector)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "Cluster") +
  theme_classic() +
  scale_fill_manual(values = palette_dissector) +
  scale_x_continuous(limits = c(0, 0.05)) +
   theme(legend.position = "none",
        axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                             length.out = length(unique(calcnums$Cluster)))))

p2 <- ggplot(calcnums, aes(x = mean_norm_count_normalizedtoNL,
                           y = factor(Cluster, levels = rev(cluster_order)),  fill = Dissector)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count_normalizedtoNL - se_mean_norm_count_normalizedtoNL, xmax = mean_norm_count_normalizedtoNL + se_mean_norm_count_normalizedtoNL),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_dissector) +
  theme(axis.text.y = element_blank(),
        legend.position = "none")


p4 <- ggplot(calcnums, aes(x = mean_normtoNL_pct, 
                           y = factor(Cluster, levels = rev(cluster_order)), fill = Dissector)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_errorbar(aes(y = Cluster, xmin = mean_normtoNL_pct - se_mean_normtoNL_pct, xmax = mean_normtoNL_pct + se_mean_normtoNL_pct),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Percent change in proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_dissector) +
  theme(axis.text.y = element_blank(),
        legend.position = "right")


wrap_plots(p1, p2, p4)
ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250217_proportionsbyDissector_1-5_5pct_res1.8_50dims_neuronal.png',
       device = png,
       width = 12,
       height = 8)

```

```{r propeller by dissector}
props.dissector <- propeller(clusters = combined.neuronal@meta.data$cell_type, sample = combined.neuronal$sample, group = combined.neuronal$Dissector, transform = "logit")

write.csv(props.dissector, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_props_Dissector_neuronal_1-5_5pct_50_1.8.csv", row.names = TRUE)
props.dissector
```

### adding cells and genes to props plot
```{r cell genes plot for dissector}
cells <- ggplot(cellsgenes_df, aes(x = 1, 
                           y = factor(Cluster, levels = rev(cluster_order)), 
                           fill = CellsPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = CellsPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 2000) +
  xlab("Cells") +
  ylab("") +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        legend.position = "none", 
        axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                             length.out = 
                                               length(unique(calcnums$Cluster)))))


genes <- ggplot(cellsgenes_df, aes(x = 1, 
                           y = factor(Cluster, levels = rev(cluster_order)), 
                           fill = GenesPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = GenesPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 19000) +
  xlab("Genes") +
  ylab("") +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none")

wrap_plots(cells, genes)
```

```{r save wrapped plot for learner}
p1_clean <- ggplot(calcnums, aes(x = mean_norm_count, 
                           y = factor(Cluster, levels = rev(cluster_order)), 
                           fill = Dissector)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_dissector) +
  scale_x_continuous(limits = c(0, 0.05)) +
   theme(axis.text.y = element_blank(),
         legend.position = "right")


wrap_plots(cells, genes, p1_clean)
ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250217_propsandDEGsbyDissector.pdf',
       device = pdf,
       width = 12,
       height = 6)
```



## by learner
First let's look at the UMAP and PCA:
```{r umap by sex}
DimPlot_scCustom(combined.neuronal,
                 colors_use = palette_learner,
                 group.by = 'Sac_Learner',
                 reduction = 'umap',
                 label = FALSE,
                 raster = FALSE,
                 split_seurat = TRUE,
                 pt.size = 0.01) +
  theme(legend.position = 'right')

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250212_umap_1-5_5pct_res1.8_50dims_neuronal_bylearner.png",
        width = 12,
        height = 12,
        dpi = 300)
```

```{r pca by sex}
DimPlot_scCustom(combined.neuronal,
                 colors_use = palette_learner,
                 group.by = 'Sac_Learner',
                 reduction = 'pca',
                 label = FALSE,
                 raster = FALSE,
                 split_seurat = TRUE,
                 pt.size = 0.01) +
  theme(legend.position = 'right')

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250212_pca_1-5_5pct_res1.8_50dims_neuronal_bylearner.png",
        width = 12,
        height = 12,
        dpi = 300)
```


```{r add learner info to df}
# map Sample to Sac_Learner
sample_to_learner <- combined.neuronal@meta.data %>%
  dplyr::select(Sample = sample, Sac_Learner) %>%
  distinct()

# Now merge this information with your celldistribution data frame
celldistribution <- celldistribution %>%
  left_join(sample_to_learner, by = "Sample")

celldistribution <- celldistribution %>%
  mutate(Sac_Learner = ifelse(Sac_Learner == 1, "Learner", 
                              ifelse(Sac_Learner == 0, "Non-Learner", as.character(Sac_Learner))))
```

```{r df with prop means by learner}
calcnums <- celldistribution %>%
  group_by(Cluster, Sac_Learner) %>%
  mutate(mean_norm_count = mean(norm_count)) %>%
  mutate(se_mean = sd(norm_count)/sqrt(36)) %>%
  drop_na()

mean_norm_count_NL_M10 <- calcnums$mean_norm_count[calcnums$Sample == "WT_M_10"]
calcnums$mean_norm_count_NL <- mean_norm_count_NL_M10[match(calcnums$Cluster, calcnums$Cluster)]

calcnums <- calcnums %>%
  mutate(norm_count_normalizedtoNL = ((norm_count / mean_norm_count_NL) - 1)) %>%
  drop_na()

# Make sure the NL mean is around 0
calcnums %>%
  filter(Sac_Learner == "Non_Learner") %>%
  group_by(Cluster) %>%
  summarize(mean = mean(norm_count_normalizedtoNL))

calcnums <- calcnums %>%
  group_by(Cluster, Sac_Learner) %>%
  mutate(mean_norm_count_normalizedtoNL = mean(norm_count_normalizedtoNL)) %>%
  mutate(se_mean_norm_count_normalizedtoNL = sd(norm_count_normalizedtoNL)/sqrt(36)) %>%
  drop_na()

calcnums <- calcnums %>%
  group_by(Cluster, Sac_Learner) %>%
  mutate(mean_normtoNL_pct = mean_norm_count_normalizedtoNL * 100) %>%
  mutate(se_mean_normtoNL_pct = se_mean_norm_count_normalizedtoNL * 100) %>%
  drop_na()

calcnums$Cluster <- factor(calcnums$Cluster)
```

```{r bar plot props by learner}
p1 <- ggplot(calcnums, aes(x = mean_norm_count, y = Cluster, fill = Sac_Learner)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
             position = position_dodge(width = 0.7),
             color = "black",
             size = 0.01) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "Cluster") +
  theme_classic() +
  scale_fill_manual(values = palette_learner) +
  theme(legend.position = "none", axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                             length.out = length(unique(calcnums$Cluster)))))


p2 <- ggplot(calcnums, aes(x = mean_norm_count_normalizedtoNL, y = Cluster, fill = Sac_Learner)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
             position = position_dodge(width = 0.7),
             color = "black",
             size = 0.01) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count_normalizedtoNL - se_mean_norm_count_normalizedtoNL, xmax = mean_norm_count_normalizedtoNL + se_mean_norm_count_normalizedtoNL),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_learner) +
  theme(axis.text.y = element_blank(),
        legend.position = "none")

p4 <- ggplot(calcnums, aes(x = mean_normtoNL_pct, y = Cluster, fill = Sac_Learner)) +
  geom_bar(stat = "identity", position = "dodge",
           width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
             position = position_dodge(width = 0.7),
             color = "black",
             size = 0.01) +
  geom_errorbar(aes(y = Cluster, xmin = mean_normtoNL_pct - se_mean_normtoNL_pct, xmax = mean_normtoNL_pct + se_mean_normtoNL_pct),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Percent change in proportion", y = "") +
  theme_classic() +
  theme(axis.text.y = element_blank()) +
  scale_fill_manual(values = palette_learner)

wrap_plots(p1, p2, p4)
ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250217_proportionsbyLearner_1-5_5pct_res1.8_50dims_neuronal.png',
       device = png,
       width = 12,
       height = 8)
```

```{r propeller by learner}
props.learner <- propeller(clusters = combined.neuronal@meta.data$cell_type, sample = combined.neuronal$sample, group = combined.neuronal$Sac_Learner, transform = "logit")

write.csv(props.learner, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_props_Learner_1-5_5pct_res1.8_50dims_neuronal.csv", row.names = TRUE)
```

### adding cells and genes to props plot
```{r selecting sig clusters from props by learner}
# Filter the data frame for P.Value < 0.05
significant_clusters <- props.learner[props.learner$P.Value < 0.05, ]

# Extract the BaselineProp.clusters for the significant results
significant_cluster_names <-sort( as.character(significant_clusters$BaselineProp.clusters))

print(significant_cluster_names)
```

```{r bar plot for sig clusters learner}
calcnums_filtered <- calcnums %>%
  filter(Cluster %in% significant_cluster_names)

# Set the factor levels to match the order in significant_cluster_names
calcnums_filtered$Cluster <- factor(calcnums_filtered$Cluster, levels = rev(significant_cluster_names))

sig_p1 <- ggplot(calcnums_filtered, aes(x = mean_norm_count, y = Cluster, fill = Sac_Learner)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
             position = position_dodge(width = 0.7),
             color = "black",
             size = 0.01) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_learner) +
  theme(legend.position = "right") +
  theme(axis.text.y = element_blank())
sig_p1
```

```{r cell genes plot for sig clusters learner}
# Create a data frame for the significant clusters
sig_cellsgenes_df <- cellsgenes_df %>%
  dplyr::filter(Cluster %in% significant_cluster_names) %>%
  dplyr::arrange(match(Cluster, significant_cluster_names))

# Ensure Cluster is a factor with levels in the correct order
sig_cellsgenes_df$Cluster <- factor(sig_cellsgenes_df$Cluster, levels = rev(significant_cluster_names))

cells <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = CellsPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = CellsPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 2000) +
  xlab("Cells") +
  ylab("") +
  theme_classic() +
  scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(axis.text.x = element_blank(),
        legend.position = "none", 
        axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                             length.out = 
                                               length(unique(calcnums$Cluster)))))


genes <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = GenesPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = GenesPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 19000) +
  xlab("Genes") +
  ylab("") +
  theme_classic() +
    scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none")

wrap_plots(cells,genes)
```

```{r save wrapped plot for learner}
wrap_plots(cells, genes, sig_p1)
ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250217_propsbyLearner_sigonly.pdf',
       device = pdf,
       width = 12,
       height = 6)
```

### adding sex as co-variate
First, let's deconstrucut propeller, according to their vignette, and make sure 
the results are the same as when running the function.
```{r propeller logit transform props}
props <- getTransformedProps(clusters = combined.neuronal$cell_type, 
                                  sample = combined.neuronal$sample, 
                                  transform = "logit")
```

```{r propeller by learner step-by-step}
# Extract var1 (Sac_Learner) from the metadata
var1 <- combined.neuronal@meta.data$Sac_Learner

# Create a data frame with sample information
sample_info <- data.frame(sample = combined.neuronal$sample, 
                          var1 = var1)

# Order the sample information based on the order of samples in prop.logit
sample_info <- sample_info[match(colnames(props$TransformedProps), sample_info$sample), ]

# Create the design matrix with var1 and var2
des <- model.matrix(~ var1, data = sample_info)

# Fit the linear model
fit <- lmFit(props$TransformedProps, des)

# Perform empirical Bayes shrinkage of the variances
fit <- eBayes(fit, robust = TRUE)

# and results for transformed proportions:
res <- topTable(fit, number=76)

# Fit the model on the original proportions scale
fit.prop <- lmFit(props$Proportions, des)
fit.prop <- eBayes(fit.prop, robust = TRUE)
res.prop <- topTable(fit.prop, number=76)

# Extract full results table for transformed proportions
res.var1 <- topTable(fit, number = Inf)

# Extract full results from original proportion analysis
res.prop.var1 <- topTable(fit.prop, number = Inf)

# Combine results for all clusters
res.combined <- data.frame(
  Cluster = rownames(res.var1),
  Sac_Learner_Coef = res.prop.var1$logFC,
  Sac_Learner_P.Value = res.var1$P.Value,
  Sac_Learner_adj.P.Val = res.var1$adj.P.Val,
  B_Sac_Learner = res.var1$B,
  AveExpr = res.var1$AveExpr
)

# Check the result
print(head(res.combined))
```
The results above should correspond entirely with the results from calling the
propeller funciton.


```{r props by learner and sex regression}
# Extract Sac_Learner and Sex from the metadata
Sac_Learner <- combined.neuronal@meta.data$Sac_Learner
Sex <- as.factor(combined.neuronal@meta.data$sex)

# Create a data frame with sample information
sample_info <- data.frame(sample = combined.neuronal$sample, 
                          Sac_Learner = Sac_Learner,
                          Sex = Sex)

# Order the sample information based on the order of samples in prop.logit
sample_info <- sample_info[match(colnames(props$TransformedProps), sample_info$sample), ]

# Create the design matrix
des <- model.matrix(~ Sac_Learner + Sex , data = sample_info)

# Fit the linear model
fit <- lmFit(props$TransformedProps, des)

# Perform empirical Bayes shrinkage of the variances
fit <- eBayes(fit, robust = TRUE)

# and results for transformed proportions:
res <- topTable(fit, number=76)

# Fit the model on the original proportions scale
fit.prop <- lmFit(props$Proportions, des)
fit.prop <- eBayes(fit.prop, robust = TRUE)
res.prop <- topTable(fit.prop, number=76)
```


```{r props by learner and sex table and save}
# Extract full results table for transformed proportions
res.sac_learner <- topTable(fit, number = Inf, coef = c("Sac_LearnerNon_Learner"))
res.sex <- topTable(fit, number = Inf, coef = c("SexM"))

# Extract full results from original proportion analysis
res.prop.sac_learner <- topTable(fit.prop, number = Inf, coef = c("Sac_LearnerNon_Learner"))
res.prop.sex <- topTable(fit.prop, number = Inf, coef = c("SexM"))

# Combine results for all clusters
res.combined <- data.frame(
  Cluster = rownames(res.sac_learner),
  Sac_Learner_Coef = res.prop.sac_learner$logFC,
  Sac_Learner_P.Value = res.sac_learner$P.Value,
  Sac_Learner_adj.P.Val = res.sac_learner$adj.P.Val,
  B_Sac_Learner = res.sac_learner$B,
  Sac_Learner_Ratio = 2^res.prop.sac_learner$logFC,  # Add this line
  Sex_Coef = res.prop.sex$logFC,
  Sex_P.Value = res.sex$P.Value,
  Sex_adj.P.Val = res.sex$adj.P.Val,
  B_Sex = res.sex$B,
  Sex_Ratio = 2^res.prop.sex$logFC,  # Add this line
  AveExpr = res.sac_learner$AveExpr  # AveExpr should be the same for both
)

# Get untransformed proportions
props_matrix <- props$Proportions

# Ensure sample_info is ordered correctly
sample_info <- sample_info[match(colnames(props_matrix), sample_info$sample), ]

# Convert props_matrix to a regular matrix
props_matrix <- as.matrix(props_matrix)

# Calculate mean proportions for each group
learner_means <- rowMeans(props_matrix[, sample_info$Sac_Learner == "Learner", drop = FALSE])
non_learner_means <- rowMeans(props_matrix[, sample_info$Sac_Learner == "Non_Learner", drop = FALSE])
male_means <- rowMeans(props_matrix[, sample_info$Sex == "M", drop = FALSE])
female_means <- rowMeans(props_matrix[, sample_info$Sex == "F", drop = FALSE])


# Add mean proportions to the results
res.combined$PropMean_Learner <- learner_means[res.combined$Cluster]
res.combined$PropMean_NonLearner <- non_learner_means[res.combined$Cluster]
res.combined$PropMean_Male <- male_means[res.combined$Cluster]
res.combined$PropMean_Female <- female_means[res.combined$Cluster]

# Calculate direct ratios
res.combined$Direct_Ratio_Learner_NonLearner <- res.combined$PropMean_Learner / res.combined$PropMean_NonLearner
res.combined$Direct_Ratio_Male_Female <- res.combined$PropMean_Male / res.combined$PropMean_Female

# Check the result
head(res.combined)

# Write to CSV
write.csv(res.combined,
          file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_props_Learner_Sex_neuronal_1-5_5pct_50dims.csv",
          row.names = FALSE)
```


### props diff. by Region
```{r add region to props df learner}
props.learner$region <- anatomical_dict[props.learner$BaselineProp.clusters]
props.learner<- props.learner %>%
  dplyr::arrange(region, FDR)
props.learner <- props.learner[order(props.learner$region, props.learner$FDR, decreasing = TRUE), ]
```

```{r p-values by region plot learner}
n_clusters <- length(unique(props.learner$BaselineProp.clusters))
text_colors <- rep(c("#000000", "#555555"), length.out = n_clusters)

ggplot(props.learner, aes(x = -log10(FDR ), 
                      y = factor(BaselineProp.clusters, 
                               levels = unique(props.learner$BaselineProp.clusters)), 
                      color = region)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(x = "-log10(P-value)",
       y = "Cluster",
       title = "Learner differences in cluster proportions") +
  theme(
    axis.text.y = element_text(size = 8,
                              color = rev(text_colors)),  # rev() to match the order of clusters
    legend.position = "right"
  )

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250220_learnerprops_pvalues_hypovother.pdf",
        width = 12,
        height = 12,
        dpi = 300)
```

```{r p-values by region plot learner top 10}
filtered_props <- props.learner %>%
  group_by(region) %>%
  arrange(FDR) %>%
  slice_head(n = 18) %>%
  ungroup() %>%
  arrange(rev(region))


filtered_props <- filtered_props[order(filtered_props$region, filtered_props$FDR, decreasing = TRUE), ]

# Then use the filtered data in your plot
ggplot(filtered_props, aes(x = -log10(FDR), 
                          y = factor(BaselineProp.clusters, 
                                   levels = unique(filtered_props$BaselineProp.clusters)), 
                          color = region)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(x = "-log10(P-value)",
       y = "Cluster",
       title = "Learner differences in cluster proportions") +
  theme(
    axis.text.y = element_text(size = 8,
                              color = rev(text_colors)[1:nrow(filtered_props)]),  # adjust colors to match filtered data
    legend.position = "right",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.line.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),  
    axis.ticks.y = element_line(color = "black")
    )
  

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250220_learnerprops_pvalues_hypovother.pdf",
        width = 6,
        height = 8,
        dpi = 300)
```

```{r Fisher's for props significance by region}
# Create contingency table of significant vs non-significant clusters by region
props.learner$significant <- props.learner$FDR < 0.05

# Create contingency table
cont_table <- with(props.learner, table(region, significant))

# Print the contingency table
print("Number of clusters by region and significance:")
print(cont_table)

# Run Fisher's exact test
fisher_result <- fisher.test(cont_table)

# Print results
print("\nFisher's exact test results:")
print(fisher_result)

# Calculate and print percentages for easier interpretation
percentages <- prop.table(cont_table, margin = 1) * 100  # margin=1 calculates percentages within each region
print("\nPercentage of significant clusters by region:")
print(percentages[,"TRUE"])
```
# Rewards by props

```{r propeller logit transform props}
# Extract the cell type proportions and transform them
props <- getTransformedProps(cluster = combined.neuronal$cell_type, 
                                  sample = combined.neuronal$sample, 
                                  transform = "logit")

head(props$TransformedProps)

# Convert props$TransformedProps to a data frame
props_df <- as.data.frame(props$TransformedProps)

names(props_df)[names(props_df) == "Freq"] <- "props_trans"

head(props_df)
str(props_df)
```

```{r merge with sample metadata}
# Create a data frame with sample information
sample_info <- data.frame(sample = combined.neuronal$sample, 
                          distance = combined.neuronal$Avg_Test_Distance,
                          rewards = combined.neuronal$Avg_Total_Rewards,
                          time = combined.neuronal$Avg_Exp_Zone_Time,
                          entries = combined.neuronal$Avg_Exp_Zone_Entries,
                          clusters = combined.neuronal$cell_type,
                          geno = combined.neuronal$genotype,
                          sex = combined.neuronal$sex,
                          learner = combined.neuronal$Sac_Learner)

head(sample_info)
str(sample_info)
```


```{r make a merged df for analysis}
merged_df <- merge(props_df, sample_info, by = c("sample", "clusters"))
rownames(merged_df) <- rownames(sample_info)

# Print the first few rows of the merged data
head(merged_df)
str(merged_df)
```

```{r linear regression rewards by props}
# Create an empty data frame to store the results
model_summary_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model
  lm_model <- lm(rewards ~ props_trans, data = cluster_df)
  
  # Extract the model summary
  model_summary <- summary(lm_model)
  
  # Create a named vector with model summary statistics
  model_summary_vec <- c(
    `(Intercept)` = coef(lm_model)[1],
    `(Intercept) p-value` = coef(model_summary)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model)[2],
    `Props Std. Error` = coef(model_summary)[2, "Std. Error"],
    `Props t value` = coef(model_summary)[2, "t value"],
    `Props p-value` = coef(model_summary)[2, "Pr(>|t|)"],
    r_squared = model_summary$r.squared,
    adj_r_squared = model_summary$adj.r.squared,
    f_statistic = model_summary$fstatistic[1],
    f_pvalue = pf(model_summary$fstatistic[1], model_summary$fstatistic[2], model_summary$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  model_summary_vec_df <- data.frame(t(model_summary_vec))
  
  # Add a column for the cluster
  model_summary_vec_df$cluster <- cluster
  
  # Append the data frame to the overall result
  model_summary_df <- rbind(model_summary_df, model_summary_vec_df)
}

# Extract the 'Props p-value' column
props_pvalues <- model_summary_df$Props.p.value

# Perform BH adjustment
bh_adjusted_pvalues <- p.adjust(props_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
model_summary_df$bh_adjusted_pvalues <- bh_adjusted_pvalues

model_summary_df %>%
  ungroup() %>% 
  arrange(bh_adjusted_pvalues)

# Print the resulting data frame
model_summary_df

write.csv(model_summary_df, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_rewardsbyprops.csv")
```

## . with Sex
```{r linear regression rewards by props and sex}
# Create an empty data frame to store the results
model_summary_sex_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model with sex added
  lm_model_sex <- lm(rewards ~ props_trans + sex, data = cluster_df)
  
  # Extract the model summary
  model_summary_sex <- summary(lm_model_sex)
  
  # Create a named vector with model summary statistics
  model_summary_vec_sex <- c(
    `(Intercept)` = coef(lm_model_sex)[1],
    `(Intercept) p-value` = coef(model_summary_sex)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model_sex)[2],
    `Props Std. Error` = coef(model_summary_sex)[2, "Std. Error"],
    `Props t value` = coef(model_summary_sex)[2, "t value"],
    `Props p-value` = coef(model_summary_sex)[2, "Pr(>|t|)"],
    `Sex` = coef(lm_model_sex)[3],
    `Sex Std. Error` = coef(model_summary_sex)[3, "Std. Error"],
    `Sex t value` = coef(model_summary_sex)[3, "t value"],
    `Sex p-value` = coef(model_summary_sex)[3, "Pr(>|t|)"],
    r_squared = model_summary_sex$r.squared,
    adj_r_squared = model_summary_sex$adj.r.squared,
    f_statistic = model_summary_sex$fstatistic[1],
    f_pvalue = pf(model_summary_sex$fstatistic[1], model_summary_sex$fstatistic[2], model_summary_sex$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  model_summary_vec_sex_df <- data.frame(t(model_summary_vec_sex))
  
  # Add a column for the cluster
  model_summary_vec_sex_df$cluster <- cluster
  
  # Append the data frame to the overall result
  model_summary_sex_df <- rbind(model_summary_sex_df, model_summary_vec_sex_df)
}

# Extract the 'Props p-value' column
props_pvalues <- model_summary_sex_df$Props.p.value
sex_pvalues <- model_summary_sex_df$Sex.p.value

# Perform BH adjustment
bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
bh_adjusted_pvalues_sex <- p.adjust(sex_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
model_summary_sex_df$bh_pvalues_props <- bh_adjusted_pvalues_props
model_summary_sex_df$bh_pvalues_sex <- bh_adjusted_pvalues_sex

model_summary_sex_df %>%
  ungroup() %>% 
  arrange(bh_pvalues_props)

# Print the resulting data frame
model_summary_sex_df

# Write the data frame to a CSV file
#write.csv(model_summary_sex_df, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_rewardsbyprops_sex.csv")

```

## . with Learner
```{r linear regression rewards by props and learner}
# Create an empty data frame to store the results
model_summary_learner_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model with learner added
  lm_model_learner <- lm(rewards ~ props_trans + learner, data = cluster_df)
  
  # Extract the model summary
  model_summary_learner <- summary(lm_model_learner)
  
  # Create a named vector with model summary statistics
  model_summary_vec_learner <- c(
    `(Intercept)` = coef(lm_model_learner)[1],
    `(Intercept) p-value` = coef(model_summary_learner)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model_learner)[2],
    `Props Std. Error` = coef(model_summary_learner)[2, "Std. Error"],
    `Props t value` = coef(model_summary_learner)[2, "t value"],
    `Props p-value` = coef(model_summary_learner)[2, "Pr(>|t|)"],
    `learner` = coef(lm_model_learner)[3],
    `learner Std. Error` = coef(model_summary_learner)[3, "Std. Error"],
    `learner t value` = coef(model_summary_learner)[3, "t value"],
    `learner p-value` = coef(model_summary_learner)[3, "Pr(>|t|)"],
    r_squared = model_summary_learner$r.squared,
    adj_r_squared = model_summary_learner$adj.r.squared,
    f_statistic = model_summary_learner$fstatistic[1],
    f_pvalue = pf(model_summary_learner$fstatistic[1], model_summary_learner$fstatistic[2], model_summary_learner$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  model_summary_vec_learner_df <- data.frame(t(model_summary_vec_learner))
  
  # Add a column for the cluster
  model_summary_vec_learner_df$cluster <- cluster
  
  # Append the data frame to the overall result
  model_summary_learner_df <- rbind(model_summary_learner_df, model_summary_vec_learner_df)
}

# Extract the 'Props p-value' column
props_pvalues <- model_summary_learner_df$Props.p.value
learner_pvalues <- model_summary_learner_df$learner.p.value

# Perform BH adjustment
bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
bh_adjusted_pvalues_learner <- p.adjust(learner_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
model_summary_learner_df$bh_pvalues_props <- bh_adjusted_pvalues_props
model_summary_learner_df$bh_pvalues_learner <- bh_adjusted_pvalues_learner

model_summary_learner_df %>%
  ungroup() %>% 
  arrange(bh_pvalues_props)

# Print the resulting data frame
model_summary_learner_df

# Write the data frame to a CSV file
write.csv(model_summary_learner_df, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_rewardsbyprops_learner.csv")

```



## Untransformed props
Checking to see that transforming the proportions (per propeller) isn't changing 
the results, and getting untransformed props for plotting.
```{r df with untransformed props}
unprops_df <- as.data.frame(props$Proportions)

names(unprops_df)[names(unprops_df) == "Freq"] <- "props_untrans"

head(unprops_df)
str(unprops_df)

new_merged_df <- merge(unprops_df, sample_info, by = c("sample", "clusters"))
#rownames(merged_df) <- rownames(sample_info)

# Print the first few rows of the merged data
head(new_merged_df)
str(new_merged_df)
```

```{r linear regression rewards by untransformed props}
# Create an empty data frame to store the results
new_model_summary_df <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model
  lm_model <- lm(rewards ~ props_untrans, data = cluster_df)
  
  # Extract the model summary
  new_model_summary <- summary(lm_model)
  
  # Create a named vector with model summary statistics
  new_model_summary_vec <- c(
    `(Intercept)` = coef(lm_model)[1],
    `(Intercept) p-value` = coef(new_model_summary)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model)[2],
    `Props Std. Error` = coef(new_model_summary)[2, "Std. Error"],
    `Props t value` = coef(new_model_summary)[2, "t value"],
    `Props p-value` = coef(new_model_summary)[2, "Pr(>|t|)"],
    r_squared = new_model_summary$r.squared,
    adj_r_squared = new_model_summary$adj.r.squared,
    f_statistic = new_model_summary$fstatistic[1],
    f_pvalue = pf(new_model_summary$fstatistic[1], new_model_summary$fstatistic[2], new_model_summary$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  new_model_summary_vec_df <- data.frame(t(new_model_summary_vec))
  
  # Add a column for the cluster
  new_model_summary_vec_df$cluster <- cluster
  
  # Append the data frame to the overall result
  new_model_summary_df <- rbind(new_model_summary_df, new_model_summary_vec_df)
}

# Extract the 'Props p-value' column
props_pvalues <- new_model_summary_df$Props.p.value

# Perform BH adjustment
bh_adjusted_pvalues <- p.adjust(props_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
new_model_summary_df$bh_adjusted_pvalues <- bh_adjusted_pvalues

arrange(new_model_summary_df, new_model_summary_df$bh_adjusted_pvalues)

# Print the resulting data frame
new_model_summary_df

write.csv(new_model_summary_df, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_rewardsbyprops_untransformed.csv")
```

```{r linear regression rewards by untransformed props and sex}
# Create an empty data frame to store the results
new_model_summary_df_sex <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model with sex added
  lm_model_sex <- lm(rewards ~ props_untrans + sex, data = cluster_df)
  
  # Extract the model summary
  new_model_summary_sex <- summary(lm_model_sex)
  
  # Create a named vector with model summary statistics
  new_model_summary_vec_sex <- c(
    `(Intercept)` = coef(lm_model_sex)[1],
    `(Intercept) p-value` = coef(new_model_summary_sex)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model_sex)[2],
    `Props Std. Error` = coef(new_model_summary_sex)[2, "Std. Error"],
    `Props t value` = coef(new_model_summary_sex)[2, "t value"],
    `Props p-value` = coef(new_model_summary_sex)[2, "Pr(>|t|)"],
    `Sex` = coef(lm_model_sex)[3],
    `Sex Std. Error` = coef(new_model_summary_sex)[3, "Std. Error"],
    `Sex t value` = coef(new_model_summary_sex)[3, "t value"],
    `Sex p-value` = coef(new_model_summary_sex)[3, "Pr(>|t|)"],
    r_squared = new_model_summary_sex$r.squared,
    adj_r_squared = new_model_summary_sex$adj.r.squared,
    f_statistic = new_model_summary_sex$fstatistic[1],
    f_pvalue = pf(new_model_summary_sex$fstatistic[1], new_model_summary_sex$fstatistic[2], new_model_summary_sex$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  new_model_summary_vec_sex_df <- data.frame(t(new_model_summary_vec_sex))
  
  # Add a column for the cluster
  new_model_summary_vec_sex_df$cluster <- cluster
  
  # Append the data frame to the overall result
  new_model_summary_df_sex <- rbind(new_model_summary_df_sex, new_model_summary_vec_sex_df)
}

# Extract the 'Props p-value' column
props_pvalues <- new_model_summary_df_sex$Props.p.value
sex_pvalues <- new_model_summary_df_sex$Sex.p.value

# Perform BH adjustment
bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
bh_adjusted_pvalues_sex <- p.adjust(sex_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
new_model_summary_df_sex$bh_pvalues_props <- bh_adjusted_pvalues_props
new_model_summary_df_sex$bh_pvalues_sex <- bh_adjusted_pvalues_sex

# Arrange the data frame by the BH-adjusted p-values
arrange(new_model_summary_df_sex, new_model_summary_df_sex$bh_adjusted_pvalues_props)

# Print the resulting data frame
new_model_summary_df_sex

# Write the data frame to a CSV file
write.csv(new_model_summary_df_sex, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_rewardsbypropsandsex_untransformed.csv")
```


```{r linear regression rewards by untransformed props and learner}
# Create an empty data frame to store the results
new_model_summary_df_learner <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model with learner added
  lm_model_learner <- lm(rewards ~ props_untrans + learner, data = cluster_df)
  
  # Extract the model summary
  new_model_summary_learner <- summary(lm_model_learner)
  
  # Create a named vector with model summary statistics
  new_model_summary_vec_learner <- c(
    `(Intercept)` = coef(lm_model_learner)[1],
    `(Intercept) p-value` = coef(new_model_summary_learner)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model_learner)[2],
    `Props Std. Error` = coef(new_model_summary_learner)[2, "Std. Error"],
    `Props t value` = coef(new_model_summary_learner)[2, "t value"],
    `Props p-value` = coef(new_model_summary_learner)[2, "Pr(>|t|)"],
    `learner` = coef(lm_model_learner)[3],
    `learner Std. Error` = coef(new_model_summary_learner)[3, "Std. Error"],
    `learner t value` = coef(new_model_summary_learner)[3, "t value"],
    `learner p-value` = coef(new_model_summary_learner)[3, "Pr(>|t|)"],
    r_squared = new_model_summary_learner$r.squared,
    adj_r_squared = new_model_summary_learner$adj.r.squared,
    f_statistic = new_model_summary_learner$fstatistic[1],
    f_pvalue = pf(new_model_summary_learner$fstatistic[1], new_model_summary_learner$fstatistic[2], new_model_summary_learner$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  new_model_summary_vec_learner_df <- data.frame(t(new_model_summary_vec_learner))
  
  # Add a column for the cluster
  new_model_summary_vec_learner_df$cluster <- cluster
  
  # Append the data frame to the overall result
  new_model_summary_df_learner <- rbind(new_model_summary_df_learner, new_model_summary_vec_learner_df)
}

# Extract the 'Props p-value' column
props_pvalues <- new_model_summary_df_learner$Props.p.value
learner_pvalues <- new_model_summary_df_learner$learner.p.value

# Perform BH adjustment
bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
bh_adjusted_pvalues_learner <- p.adjust(learner_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
new_model_summary_df_learner$bh_pvalues_props <- bh_adjusted_pvalues_props
new_model_summary_df_learner$bh_pvalues_learner <- bh_adjusted_pvalues_learner

# Arrange the data frame by the BH-adjusted p-values
arrange(new_model_summary_df_learner, new_model_summary_df_learner$bh_adjusted_pvalues_props)

# Print the resulting data frame
new_model_summary_df_learner

# Write the data frame to a CSV file
write.csv(new_model_summary_df_learner, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_rewardsbypropsandlearner_untransformed.csv")
```


## Scatterplots 
```{r fxn for scatterplots rewards by untrans props}
plot_cluster <- function(i, model_summary_df, new_merged_df) {
  # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_df[model_summary_df$cluster == i, ]
  
  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == i) %>% 
    distinct()
  
  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$rewards, 
       main = paste("Cluster", i),
       pch = 16, cex = 2, 
       xlab = "Props_untrans", ylab = "Rewards", 
       cex.lab = 1.5, cex.axis = 1.5,
       xlim = c(0, max(cluster_df$props_untrans)),
       cex.main = 2)
  
  # Fit lines for all data, male, and female
  fit_all <- lm(rewards ~ props_untrans, data = cluster_df)
  
  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)
  
  # Calculate R-squared value
  r2_all <- summary(fit_all)$r.squared
  
  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_adjusted_pvalues , digits = 3))
  )
  
  # Add legend
  legend("topleft", 
         legend = legend_labels,
         col = c("black", "black", "black", "black"),
         lty = c(1, NA, NA, NA),
         cex = 1.2,
         bty = "n")
}
```

```{r plot scatters rewards by untrans props}
# Get all unique cluster numbers
clusters <- unique(model_summary_sex_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("./SocOp_MYT1L_snRNAseq_SS19_240328/results/RewardsbyProp", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("./SocOp_MYT1L_snRNAseq_SS19_240328/results/RewardsbyProp/cluster_", cluster, "_plot.pdf"), width = 6, height = 8)
  
  # Create the plot
  plot_cluster(cluster, model_summary_df, new_merged_df)
  
  # Close the PDF device
  dev.off()
  
  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'RewardsbyProp' directory.\n")
```

### by Sex

```{r  fxn for scatterplots rewards by untrans props and sex}
plot_cluster_bysex <- function(i, model_summary_sex_df, new_merged_df) {
     # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_sex_df[model_summary_sex_df$cluster == i, ]
  
  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == i) %>% 
    distinct()
  
   
  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$rewards, 
       main = paste("Cluster", i),
       pch = 16, cex = 2, 
       xlab = "Props_untrans", ylab = "Rewards", 
       cex.lab = 1.5, cex.axis = 1.5,
       cex.main = 2, 
       xlim = c(0, max(cluster_df$props_untrans)),         
       col = ifelse(cluster_df$sex == "M", "#4478AB", "#ED6677"))
  
  # Fit lines for all data, male, and female
  fit_all <- lm(rewards ~ props_untrans, data = cluster_df)
  fit_male <- lm(rewards ~ props_untrans, data = cluster_df[cluster_df$sex == "M", ])
  fit_female <- lm(rewards ~ props_untrans, data = cluster_df[cluster_df$sex == "F", ])
  
  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)
  abline(fit_male, col = "#4478AB", lwd = 2)
  abline(fit_female, col = "#ED6677", lwd = 2)
  
  # Calculate R-squared values for each fit
  r2_all <- summary(fit_all)$r.squared
  r2_male <- summary(fit_male)$r.squared
  r2_female <- summary(fit_female)$r.squared
  
  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("Male (R =", round(r2_male, 3), ")"),
    paste("Female (R =", round(r2_female, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_pvalues_props , digits = 3))
  )
  
  # Add legend
  legend("topleft", 
         legend = legend_labels,
         col = c("black", "#4478AB", "#ED6677", "black", "black", "black"),
         lty = c(1, 1, 1, NA, NA, NA),
         cex = 1.2,
         bty = "n")
}
```

```{r plot scatters rewards by untrans props and sex}
# Get all unique cluster numbers
clusters <- unique(model_summary_sex_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("./SocOp_MYT1L_snRNAseq_SS19_240328/results/RewardsbyProp", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("./SocOp_MYT1L_snRNAseq_SS19_240328/results/RewardsbyProp/cluster_", cluster, "_plotwithSex.pdf"), width = 6, height = 8)
  
  # Create the plot
  plot_cluster_bysex(cluster, model_summary_sex_df, new_merged_df)
  
  # Close the PDF device
  dev.off()
  
  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'RewardsbyProp' directory.\n")
```


### by Learner

```{r  fxn for scatterplots rewards by untrans props and learner}
plot_cluster_bylearner <- function(i, model_summary_learner_df, new_merged_df) {
  # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_learner_df[model_summary_learner_df$cluster == i, ]
  
  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == i) %>% 
    distinct()
  
  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$rewards, 
       main = paste("Cluster", i),
       pch = 16, cex = 2, 
       xlab = "Props_untrans", ylab = "Rewards", 
       cex.lab = 1.5, cex.axis = 1.5,
       cex.main = 2, 
       xlim = c(0, max(cluster_df$props_untrans)),         
       col = ifelse(cluster_df$learner == "Learner", "#547B80", "#D1D3D4"))
  
  # Fit lines for all data, learner, and non_learner
  fit_all <- lm(rewards ~ props_untrans, data = cluster_df)
  fit_learner <- lm(rewards ~ props_untrans, data = cluster_df[cluster_df$learner == "Learner", ])
  fit_non_learner <- lm(rewards ~ props_untrans, data = cluster_df[cluster_df$learner == "Non_Learner", ])
  
  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)
  abline(fit_learner, col = "#547B80", lwd = 2)
  abline(fit_non_learner, col = "#D1D3D4", lwd = 2)
  
  # Calculate R-squared values for each fit
  r2_all <- summary(fit_all)$r.squared
  r2_learner <- summary(fit_learner)$r.squared
  r2_non_learner <- summary(fit_non_learner)$r.squared
  
  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("learner (R =", round(r2_learner, 3), ")"),
    paste("non_learner (R =", round(r2_non_learner, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_pvalues_props , digits = 3))
  )
  
  # Add legend
  legend("topleft", 
         legend = legend_labels,
         col = c("black", "#547B80", "#D1D3D4", "black", "black", "black"),
         lty = c(1, 1, 1, NA, NA, NA),
         cex = 1.2,
         bty = "n")
}
```

```{r plot scatters rewards by untrans props and learner}
# Get all unique cluster numbers
clusters <- unique(model_summary_learner_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("./SocOp_MYT1L_snRNAseq_SS19_240328/results/RewardsbyProp", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("./SocOp_MYT1L_snRNAseq_SS19_240328/results/RewardsbyProp/cluster_", cluster, "_plotwithLearner.pdf"), width = 6, height = 8)
  
  # Create the plot
  plot_cluster_bylearner(cluster, model_summary_learner_df, new_merged_df)
  
  # Close the PDF device
  dev.off()
  
  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'RewardsbyProp' directory.\n")
```

## Plotting B values
```{r plotting beta coefficients rewards}
# Assuming your data frame is called model_summary_df
p_beta <- ggplot(model_summary_df, 
       aes(x = Props.props_trans, y = cluster)) +
  geom_bar(stat = "identity", 
           width = 0.7,
           fill = "#888888") +
  geom_errorbar(aes(xmin = Props.props_trans - Props.Std..Error, 
                    xmax = Props.props_trans + Props.Std..Error),
                position = position_dodge(0.7),
                width = 0.2, 
                size = 0.2) +
  labs(x = "Beta Coefficient", 
       y = "Cluster") +
  theme_classic() +
  theme(legend.position = "none",
        axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                 length.out = length(unique(model_summary_df$cluster)))))

p_beta
ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250218_rewardsbyprops_betacoeffs.pdf',
       device = pdf,
       width = 6,
       height = 8)
```

```{r selecting sig clusters from rewards by props}
significant_clusters_rewards <- model_summary_df[model_summary_df$bh_adjusted_pvalues < 0.05, ]

significant_clusters_rewards_names <-sort(as.character(significant_clusters_rewards$cluster))
print(significant_clusters_rewards_names)
```

```{r merging sig clusters for rewards and learner}
merged_sig_clusters <- union(significant_cluster_names, significant_clusters_rewards_names)
merged_sig_clusters <-sort(as.character(merged_sig_clusters))
print(merged_sig_clusters)
```


```{r beta coefficient plot for merged sig clusters}
model_summary_df_filtered <- model_summary_df %>%
  filter(cluster %in% merged_sig_clusters)

# Set the factor levels to match the order in significant_cluster_names
model_summary_df_filtered$cluster <- factor(model_summary_df_filtered$cluster, levels = rev(merged_sig_clusters))

p_beta_sig <- ggplot(model_summary_df_filtered, 
       aes(x = Props.props_trans, y = cluster)) +
  geom_bar(stat = "identity", 
           width = 0.7,
           fill = "#888888") +
  geom_errorbar(aes(xmin = Props.props_trans - Props.Std..Error, 
                    xmax = Props.props_trans + Props.Std..Error),
                position = position_dodge(0.7),
                width = 0.2, 
                size = 0.2) +
  labs(x = "Beta Coefficient", 
       y = "") +
  theme_classic() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

p_beta_sig
```


```{r cells and genes plot for sig clusters rewards and learner}
sig_cellsgenes_df <- cellsgenes_df %>%
  dplyr::filter(Cluster %in% merged_sig_clusters) %>%
  arrange(match(Cluster, merged_sig_clusters))

# Ensure Cluster is a factor with levels in the correct order
sig_cellsgenes_df$Cluster <- factor(sig_cellsgenes_df$Cluster, levels = rev(merged_sig_clusters))

cells <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = CellsPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = CellsPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 2000) +
  ylab("") +
  xlab("Nuclei") +
  theme_classic() +
  scale_y_discrete(limits = rev(merged_sig_clusters)) +
  theme(axis.text.x = element_blank(),
        legend.position = "none",
        axis.text.y = element_text(color = rep(c("#000000", "#555555"), 
                                             length.out = length(unique(calcnums$Cluster)))))

genes <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = GenesPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = GenesPerCluster)) +
  scale_fill_gradient2(low = "#757575",
                       mid = "#9E9E9E",
                       high = "#FAFAFA",
                       midpoint = 19000) +
  ylab("") +
  xlab("Genes") +
  theme_classic() +
    scale_y_discrete(limits = rev(merged_sig_clusters)) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        legend.position = "none")

wrap_plots(cells,genes)
```

```{r bar plot props by learner for merged sig clusters}
calcnums_filtered <- calcnums %>%
  filter(Cluster %in% merged_sig_clusters)

# Set the factor levels to match the order in significant_cluster_names
calcnums_filtered$Cluster <- factor(calcnums_filtered$Cluster, levels = rev(merged_sig_clusters))

merged_sig_p1 <- ggplot(calcnums_filtered, aes(x = mean_norm_count, y = Cluster, fill = Sac_Learner)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
             position = position_dodge(width = 0.7),
             color = "black",
             size = 0.01) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
                position = position_dodge(0.7),
                width = 0.2, size = 0.2) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_learner) +
  theme(legend.position = "right") +
  theme(axis.text.y = element_blank())
merged_sig_p1
``` 

```{r save plot with beta coeffs and props by learner}
wrap_plots(cells, genes, merged_sig_p1, p_beta_sig, nrow = 1)

ggsave('./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250218_propsbyLearnerandbetacoeffsforRewards_sigonly.pdf',
       device = pdf,
       width = 20,
       height = 4)
```


## props diff. by Region
```{r add region to props df rewards}
model_summary_df$region <- anatomical_dict[model_summary_df$cluster]
model_summary_df<- model_summary_df %>%
  dplyr::arrange(region, bh_adjusted_pvalues)
model_summary_df <- model_summary_df[order(model_summary_df$region, model_summary_df$bh_adjusted_pvalues, decreasing = TRUE), ]
```

```{r p-values by region plot rewards}
n_clusters <- length(unique(model_summary_df$bh_adjusted_pvalues))
text_colors <- rep(c("#000000", "#555555"), length.out = n_clusters)

ggplot(model_summary_df, aes(x = -log10(bh_adjusted_pvalues), 
                      y = factor(cluster, 
                               levels = unique(model_summary_df$cluster)), 
                      color = region)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(x = "-log10(P-value)",
       y = "Cluster",
       title = "Differences in cluster proportions as predictors of rewards") +
  theme(
    axis.text.y = element_text(size = 8,
                              color = rev(text_colors)),  # rev() to match the order of clusters
    legend.position = "right"
  )

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/intermed_figs/250220_rewardsprops_pvalues_hypovother.pdf",
        width = 12,
        height = 12,
        dpi = 300)
```

```{r p-values by region plot rewards top 10}
filtered_model_summary_df <- model_summary_df %>%
  group_by(region) %>%
  arrange(bh_adjusted_pvalues) %>%
  slice_head(n = 10) %>%
  ungroup() %>%
  arrange(rev(region))

# Then use the filtered data in your plot
ggplot(filtered_model_summary_df, aes(x = -log10(bh_adjusted_pvalues), 
                          y = factor(cluster, 
                                   levels = unique(filtered_model_summary_df$cluster)), 
                          color = region)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(x = "-log10(P-value)",
       y = "Cluster",
       title = "Differences in cluster proportions as predictors of rewards") +
  theme(
    axis.text.y = element_text(size = 8,
                              color = rev(text_colors)[1:nrow(filtered_model_summary_df)]),  # adjust colors to match filtered data
    legend.position = "right",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.line.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),  
    axis.ticks.y = element_line(color = "black")
    )
  

 ggsave(filename = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/final_figs/250220_rewardsprops_pvalues_hypovother.pdf",
        width = 6,
        height = 8,
        dpi = 300)
```

```{r Fisher's for rewards props significance by region}
# Create contingency table of significant vs non-significant clusters by region
model_summary_df$significant <- model_summary_df$bh_adjusted_pvalues < 0.05

# Create contingency table
cont_table <- with(model_summary_df, table(region, significant))

# Print the contingency table
print("Number of clusters by region and significance:")
print(cont_table)

# Run Fisher's exact test
fisher_result <- fisher.test(cont_table)

# Print results
print("\nFisher's exact test results:")
print(fisher_result)

# Calculate and print percentages for easier interpretation
percentages <- prop.table(cont_table, margin = 1) * 100  # margin=1 calculates percentages within each region
print("\nPercentage of significant clusters by region:")
print(percentages[,"TRUE"])
```


# Distance by Props
```{r linear regression distance by props}
# Create an empty data frame to store the results
model_summary_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model
  lm_model <- lm(distance ~ props_trans, data = cluster_df)
  
  # Extract the model summary
  model_summary <- summary(lm_model)
  
  # Create a named vector with model summary statistics
  model_summary_vec <- c(
    `(Intercept)` = coef(lm_model)[1],
    `(Intercept) p-value` = coef(model_summary)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model)[2],
    `Props Std. Error` = coef(model_summary)[2, "Std. Error"],
    `Props t value` = coef(model_summary)[2, "t value"],
    `Props p-value` = coef(model_summary)[2, "Pr(>|t|)"],
    r_squared = model_summary$r.squared,
    adj_r_squared = model_summary$adj.r.squared,
    f_statistic = model_summary$fstatistic[1],
    f_pvalue = pf(model_summary$fstatistic[1], model_summary$fstatistic[2], model_summary$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  model_summary_vec_df <- data.frame(t(model_summary_vec))
  
  # Add a column for the cluster
  model_summary_vec_df$cluster <- cluster
  
  # Append the data frame to the overall result
  model_summary_df <- rbind(model_summary_df, model_summary_vec_df)
}

# Extract the 'Props p-value' column
props_pvalues <- model_summary_df$Props.p.value

# Perform BH adjustment
bh_adjusted_pvalues <- p.adjust(props_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
model_summary_df$bh_pvalues_props <- bh_adjusted_pvalues


model_summary_df %>%
  ungroup() %>% 
  arrange(bh_pvalues_props)

# Print the resulting data frame
model_summary_df

write.csv(model_summary_df, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_distancebyprops.csv")
```

## . with Sex
```{r linear regression distance by props and sex}
# Create an empty data frame to store the results
model_summary_sex_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model with sex added
  lm_model_sex <- lm(distance ~ props_trans + sex, data = cluster_df)
  
  # Extract the model summary
  model_summary_sex <- summary(lm_model_sex)
  
  # Create a named vector with model summary statistics
  model_summary_vec_sex <- c(
    `(Intercept)` = coef(lm_model_sex)[1],
    `(Intercept) p-value` = coef(model_summary_sex)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model_sex)[2],
    `Props Std. Error` = coef(model_summary_sex)[2, "Std. Error"],
    `Props t value` = coef(model_summary_sex)[2, "t value"],
    `Props p-value` = coef(model_summary_sex)[2, "Pr(>|t|)"],
    `Sex` = coef(lm_model_sex)[3],
    `Sex Std. Error` = coef(model_summary_sex)[3, "Std. Error"],
    `Sex t value` = coef(model_summary_sex)[3, "t value"],
    `Sex p-value` = coef(model_summary_sex)[3, "Pr(>|t|)"],
    r_squared = model_summary_sex$r.squared,
    adj_r_squared = model_summary_sex$adj.r.squared,
    f_statistic = model_summary_sex$fstatistic[1],
    f_pvalue = pf(model_summary_sex$fstatistic[1], model_summary_sex$fstatistic[2], model_summary_sex$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  model_summary_vec_sex_df <- data.frame(t(model_summary_vec_sex))
  
  # Add a column for the cluster
  model_summary_vec_sex_df$cluster <- cluster
  
  # Append the data frame to the overall result
  model_summary_sex_df <- rbind(model_summary_sex_df, model_summary_vec_sex_df)
}

# Extract the 'Props p-value' column
props_pvalues <- model_summary_sex_df$Props.p.value
sex_pvalues <- model_summary_sex_df$Sex.p.value

# Perform BH adjustment
bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
bh_adjusted_pvalues_sex <- p.adjust(sex_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
model_summary_sex_df$bh_pvalues_props <- bh_adjusted_pvalues_props
model_summary_sex_df$bh_pvalues_sex <- bh_adjusted_pvalues_sex

model_summary_sex_df %>%
  ungroup() %>% 
  arrange(bh_pvalues_props)

# Print the resulting data frame
model_summary_sex_df

# Write the data frame to a CSV file
write.csv(model_summary_sex_df, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_distancebyprops_sex.csv")

```

## Untransformed props
Checking to see that transforming the proportions (per propeller) isn't changing 
the results, and getting untransformed props for plotting.

```{r linear regression distance by untransformed props}
# Create an empty data frame to store the results
new_model_summary_df <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model
  lm_model <- lm(distance ~ props_untrans, data = cluster_df)
  
  # Extract the model summary
  new_model_summary <- summary(lm_model)
  
  # Create a named vector with model summary statistics
  new_model_summary_vec <- c(
    `(Intercept)` = coef(lm_model)[1],
    `(Intercept) p-value` = coef(new_model_summary)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model)[2],
    `Props Std. Error` = coef(new_model_summary)[2, "Std. Error"],
    `Props t value` = coef(new_model_summary)[2, "t value"],
    `Props p-value` = coef(new_model_summary)[2, "Pr(>|t|)"],
    r_squared = new_model_summary$r.squared,
    adj_r_squared = new_model_summary$adj.r.squared,
    f_statistic = new_model_summary$fstatistic[1],
    f_pvalue = pf(new_model_summary$fstatistic[1], new_model_summary$fstatistic[2], new_model_summary$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  new_model_summary_vec_df <- data.frame(t(new_model_summary_vec))
  
  # Add a column for the cluster
  new_model_summary_vec_df$cluster <- cluster
  
  # Append the data frame to the overall result
  new_model_summary_df <- rbind(new_model_summary_df, new_model_summary_vec_df)
}

# Extract the 'Props p-value' column
props_pvalues <- new_model_summary_df$Props.p.value

# Perform BH adjustment
bh_adjusted_pvalues <- p.adjust(props_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
new_model_summary_df$bh_adjusted_pvalues <- bh_adjusted_pvalues

arrange(new_model_summary_df, new_model_summary_df$bh_adjusted_pvalues)

# Print the resulting data frame
new_model_summary_df

write.csv(new_model_summary_df, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_distancebyprops_untransformed.csv")
```

```{r linear regression distance by untransformed props and sex}
# Create an empty data frame to store the results
new_model_summary_df_sex <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == cluster) %>% 
    distinct
  
  # Fit the linear regression model with sex added
  lm_model_sex <- lm(distance ~ props_untrans + sex, data = cluster_df)
  
  # Extract the model summary
  new_model_summary_sex <- summary(lm_model_sex)
  
  # Create a named vector with model summary statistics
  new_model_summary_vec_sex <- c(
    `(Intercept)` = coef(lm_model_sex)[1],
    `(Intercept) p-value` = coef(new_model_summary_sex)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model_sex)[2],
    `Props Std. Error` = coef(new_model_summary_sex)[2, "Std. Error"],
    `Props t value` = coef(new_model_summary_sex)[2, "t value"],
    `Props p-value` = coef(new_model_summary_sex)[2, "Pr(>|t|)"],
    `Sex` = coef(lm_model_sex)[3],
    `Sex Std. Error` = coef(new_model_summary_sex)[3, "Std. Error"],
    `Sex t value` = coef(new_model_summary_sex)[3, "t value"],
    `Sex p-value` = coef(new_model_summary_sex)[3, "Pr(>|t|)"],
    r_squared = new_model_summary_sex$r.squared,
    adj_r_squared = new_model_summary_sex$adj.r.squared,
    f_statistic = new_model_summary_sex$fstatistic[1],
    f_pvalue = pf(new_model_summary_sex$fstatistic[1], new_model_summary_sex$fstatistic[2], new_model_summary_sex$fstatistic[3], lower.tail = FALSE)
  )
  
  # Convert the named vector to a data frame
  new_model_summary_vec_sex_df <- data.frame(t(new_model_summary_vec_sex))
  
  # Add a column for the cluster
  new_model_summary_vec_sex_df$cluster <- cluster
  
  # Append the data frame to the overall result
  new_model_summary_df_sex <- rbind(new_model_summary_df_sex, new_model_summary_vec_sex_df)
}

# Extract the 'Props p-value' column
props_pvalues <- new_model_summary_df_sex$Props.p.value
sex_pvalues <- new_model_summary_df_sex$Sex.p.value

# Perform BH adjustment
bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
bh_adjusted_pvalues_sex <- p.adjust(sex_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
new_model_summary_df_sex$bh_pvalues_props <- bh_adjusted_pvalues_props
new_model_summary_df_sex$bh_pvalues_sex <- bh_adjusted_pvalues_sex

# Arrange the data frame by the BH-adjusted p-values
arrange(new_model_summary_df_sex, new_model_summary_df_sex$bh_adjusted_pvalues_props)

# Print the resulting data frame
new_model_summary_df_sex

# Write the data frame to a CSV file
write.csv(new_model_summary_df_sex, file = "./SocOp_MYT1L_snRNAseq_SS19_240328/results/250217_distancebypropsandsex_untransformed.csv")
```
## Scatterplots 
```{r fxn for scatterplots distance by untrans props}
plot_cluster <- function(i, model_summary_df, new_merged_df) {
  # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_df[model_summary_df$cluster == i, ]
  
  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == i) %>% 
    distinct()
  
  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$distance, 
       main = paste("Cluster", i),
       pch = 16, cex = 2, 
       xlab = "Props_untrans", ylab = "distance", 
       cex.lab = 1.5, cex.axis = 1.5,
       xlim = c(0, max(cluster_df$props_untrans)),
       cex.main = 2)
  
  # Fit lines for all data, male, and female
  fit_all <- lm(distance ~ props_untrans, data = cluster_df)
  
  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)
  
  # Calculate R-squared value
  r2_all <- summary(fit_all)$r.squared
  
  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_adjusted_pvalues , digits = 3))
  )
  
  # Add legend
  legend("topleft", 
         legend = legend_labels,
         col = c("black", "black", "black", "black"),
         lty = c(1, NA, NA, NA),
         cex = 1.2,
         bty = "n")
}
```

```{r plot scatters distance by untrans props}
# Get all unique cluster numbers
clusters <- unique(model_summary_sex_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("./SocOp_MYT1L_snRNAseq_SS19_240328/results/DistancebyProp", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("./SocOp_MYT1L_snRNAseq_SS19_240328/results/DistancebyProp/cluster_", cluster, "_plot.pdf"), width = 6, height = 8)
  
  # Create the plot
  plot_cluster(cluster, model_summary_df, new_merged_df)
  
  # Close the PDF device
  dev.off()
  
  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'DistancebyProp' directory.\n")
```


### by Sex

```{r  fxn for scatterplots distance by untrans props and sex}
plot_cluster_bysex <- function(i, model_summary_sex_df, new_merged_df) {
  # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_sex_df[model_summary_sex_df$cluster == i, ]
 
  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>% 
    filter(clusters == i) %>% 
    distinct()
 
  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$distance, 
       main = paste("Cluster", i),
       pch = 16, cex = 2, 
       xlab = "Props_untrans", ylab = "Distance", 
       cex.lab = 1.5, cex.axis = 1.5,
       cex.main = 2, 
       xlim = c(0, max(cluster_df$props_untrans)),         
       col = ifelse(cluster_df$sex == "M", "#4478AB", "#ED6677"))
  
  # Fit lines for all data, male, and female
  fit_all <- lm(distance ~ props_untrans, data = cluster_df)
  fit_male <- lm(distance ~ props_untrans, data = cluster_df[cluster_df$sex == "M", ])
  fit_female <- lm(distance ~ props_untrans, data = cluster_df[cluster_df$sex == "F", ])
  
  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)
  abline(fit_male, col = "#4478AB", lwd = 2)
  abline(fit_female, col = "#ED6677", lwd = 2)
  
  # Calculate R-squared values for each fit
  r2_all <- summary(fit_all)$r.squared
  r2_male <- summary(fit_male)$r.squared
  r2_female <- summary(fit_female)$r.squared
  
  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("Male (R =", round(r2_male, 3), ")"),
    paste("Female (R =", round(r2_female, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_pvalues_props , digits = 3))
  )
  
  # Add legend
  legend("topleft", 
         legend = legend_labels,
         col = c("black", "#4478AB", "#ED6677", "black", "black", "black"),
         lty = c(1, 1, 1, NA, NA, NA),
         cex = 1.2,
         bty = "n")
}
```

```{r plot scatters distance by untrans props and sex}
# Get all unique cluster numbers
clusters <- unique(model_summary_sex_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("./SocOp_MYT1L_snRNAseq_SS19_240328/results/DistancebyProp", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("./SocOp_MYT1L_snRNAseq_SS19_240328/results/DistancebyProp/cluster_", cluster, "_plotwithSex.pdf"), width = 6, height = 8)
  
  # Create the plot
  plot_cluster_bysex(cluster, model_summary_sex_df, new_merged_df)
  
  # Close the PDF device
  dev.off()
  
  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'DistancebyProp' directory.\n")
```
# End
