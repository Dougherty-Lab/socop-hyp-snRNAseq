---
title: "Analysis of proportion differences in MYT1L tuberal hypothalamus after social operant conditioning"
author: "Simona Sarafinovska"
date: "2025-02-18"
---

# Set up environment
```{r dependencies, warning=FALSE, message=FALSE}
# Change this to your directory
.libPaths("/ref/jdlab/software/r-envs/simona/r-packages/4.2/")

# Load dependencies
library(dplyr)
library(Seurat)
library(patchwork)
library(Matrix)
library(ggplot2)
library(cowplot)
library(RColorBrewer)
library(scCustomize)
library(patchwork)
library(qs)
library(viridis)
library(ggpubr)
library(SeuratDisk)
library(SeuratWrappers)
library(ComplexHeatmap)
library(stringr)
library(ggrastr)
library(parallel)
library(ggtree)
library(speckle)
library(limma)
library(gt)
library(data.table)
library(biomaRt)
library(tidyr)
library(compositions)
library(lisi)

set.seed(420)

source("../color_utils.R")
```

# Load in preprocessed data

```{r load in data}
combined_neuronal <- readRDS("../../data/250228_combined.neuronal_1-5_5pct.rds")
combined_neuronal
```

```{r metadata formatting}
# Saving scatterplots won't work if you have "/" in cluster name
combined_neuronal@meta.data$cell_type <- as.factor(gsub("/", "-", combined_neuronal@meta.data$cell_type))
```


```{r subset for wt only}
# Subset the Seurat object to keep only WT cells
wt_only <- subset(combined_neuronal, subset = genotype == "WT")

# Verify the subsetting worked correctly
table(wt_only$genotype)
```

```{r drop unused sample levels}
# Drop unused factor levels from the sample column
wt_only$sample <- droplevels(wt_only$sample)

# Verify that only WT samples remain
levels(wt_only$sample)
```

# Props by ...
```{r make proportions df}
celldistribution <- data.frame(table(wt_only@meta.data$cell_type, wt_only@meta.data$sample))
colnames(celldistribution) <- c("Cluster", "Sample", "Number")
celldistribution$Sex <- gsub(".*_(\\w)_.*", "\\1", celldistribution$Sample)
celldistribution <- celldistribution %>%
  group_by(Sample) %>%
  mutate(norm_count = Number / sum(Number)) %>%
  ungroup()

celldistribution$Sex <- factor(celldistribution$Sex, levels = c("M", "F"))

celldistribution
```

```{r cell and gene numbers df}
cluster.set <- rev(levels(wt_only@meta.data$cell_type))

cells.per.cluster <- c(table(wt_only$cell_type)[as.character(cluster.set)])
counts <- GetAssayData(wt_only, assay = "RNA", slot = "counts")
cell_idents <- wt_only$cell_type

# Function to count unique genes for a set of cells
count_unique_genes <- function(cell_indices) {
  sum(rowSums(counts[, cell_indices, drop = FALSE]) > 0)
}

# Get unique genes per cluster
genes.per.cluster <- sapply(levels(cell_idents), function(ident) {
  cells_in_cluster <- which(cell_idents == ident)
  count_unique_genes(cells_in_cluster)
})

# Name the results with cluster identities
names(genes.per.cluster) <- levels(cell_idents)

cellsgenes_df <- data.frame(
  Cluster = cluster.set,
  CellsPerCluster = cells.per.cluster,
  GenesPerCluster = genes.per.cluster
)
```

## by sex. 
First let's look at the UMAP and PCA:
```{r umap by sex}
DimPlot_scCustom(wt_only,
  colors_use = palette_sex,
  group.by = "sex",
  reduction = "umap",
  label = FALSE,
  raster = FALSE,
  split_seurat = TRUE,
  pt.size = 0.01
) +
  theme(legend.position = "right")

ggsave(
  filename = "../../results/proportions_WTonly/250301_umap_1-5_5pct_res1.8_50dims_neuronal_bysex.png",
  width = 12,
  height = 12,
  dpi = 300
)
```

```{r pca by sex}
DimPlot_scCustom(wt_only,
  colors_use = palette_sex,
  group.by = "sex",
  reduction = "pca",
  label = FALSE,
  raster = FALSE,
  split_seurat = TRUE,
  pt.size = 0.01
) +
  theme(legend.position = "right")

ggsave(
  filename = "../../results/proportions_WTonly/intermed-figs/250301_pca_1-5_5pct_res1.8_50dims_neuronal_bysex.png",
  width = 12,
  height = 12,
  dpi = 300
)
```

Next let's consider Moxd1, an marker for sex-dimorphic neurons in hypothalamus, BNST, and amygdala ().

### Moxd1

```{r moxd1 violin plot}
VlnPlot(wt_only,
  group.by = "sex",
  features = "Moxd1",
  pt.size = 0.1,
  adjust = 1.5
) +
  scale_y_continuous(breaks = seq(0, 3, 0.5)) +
  theme_classic()
```

```{r moxd1 violin in non-zero nucs}
gene_expr <- GetAssayData(wt_only, slot = "data")["Moxd1", ]

# Create a binary vector for expression
binary_expr <- ifelse(gene_expr > 0, 1, 0)

# Calculate percentage of expressing cells per group
expr_freq <- tapply(binary_expr, wt_only$sex, mean) * 100

# Plot non-zero values only
VlnPlot_scCustom(wt_only[, gene_expr > 0],
  group.by = "sex",
  features = "Moxd1",
  pt.size = 1
) +
  ggtitle(paste0(
    "Moxd1 expression\n",
    "% expressing cells: F=", round(expr_freq["F"], 1),
    "%, M=", round(expr_freq["M"], 1), "%"
  ))

ggsave(
  filename = "../../results/proportions_WTonly/250301_Moxd1GEX_bysex.pdf",
  device = pdf,
  width = 6,
  height = 8
)
```

```{r wilcoxon test Moxd1 GEX}
test_data <- data.frame(
  Moxd1 = gene_expr,
  sex = wt_only$sex
)

# Perform Wilcoxon test on non-zero values
wilcox_test <- wilcox.test(
  Moxd1 ~ sex,
  data = test_data[test_data$Moxd1 > 0, ],
  exact = FALSE
)

print(wilcox_test)
```

```{r}
# Define logit function
logit <- function(p) log(p / (1 - p))

moxd1_data <- data.frame(
  sample = wt_only$sample,
  sex = wt_only$sex,
  Moxd1 = GetAssayData(wt_only, slot = "data")["Moxd1", ]
)

# First calculate proportions by sample
moxd1_props <- moxd1_data %>%
  group_by(sample, sex) %>%
  summarize(
    total_cells = n(),
    expressing_cells = sum(Moxd1 > 0),
    proportion = expressing_cells / total_cells,
    .groups = "drop"
  )

# Logit transform the proportions for statistics
moxd1_props$transformed_prop <- logit(pmin(pmax(moxd1_props$proportion, 0.001), 0.999))
moxd1_props$standardized_prop <- scale(moxd1_props$transformed_prop)

# Fit linear model on transformed data
fit <- lm(standardized_prop ~ sex, data = moxd1_props)
summary_stats <- summary(fit)

# Calculate means and SE for untransformed proportions
sex_stats_raw <- moxd1_props %>%
  group_by(sex) %>%
  summarize(
    mean_prop = mean(proportion),
    se = sd(proportion) / sqrt(n()),
    .groups = "drop"
  )

# Plot with untransformed proportions
ggplot() +
  geom_bar(
    data = sex_stats_raw,
    aes(x = sex, y = mean_prop, fill = sex),
    stat = "identity",
    alpha = 0.8,
    width = 0.5
  ) +
  geom_errorbar(
    data = sex_stats_raw,
    aes(
      x = sex,
      ymin = mean_prop - se,
      ymax = mean_prop + se
    ),
    width = 0.2
  ) +
  geom_point(
    data = moxd1_props,
    aes(x = sex, y = proportion),
    position = position_jitter(width = 0.2),
    size = 1
  ) +
  scale_fill_manual(values = palette_sex) +
  theme_classic() +
  theme(
    legend.position = "none",
    axis.line = element_line(color = "black"),
    axis.text = element_text(color = "black", size = 12),
    axis.title = element_text(size = 14)
  ) +
  ylab("Proportion of Moxd1+ Nuclei") +
  xlab("Sex")

ggsave(
  filename = "../../results/proportions_WTonly/250301_Moxd1props_bysex.pdf",
  device = pdf,
  width = 6,
  height = 8
)

# Print model results (from transformed data)
print(summary_stats)
```

## Untargeted

```{r df with prop means by sex}
calcnums <- celldistribution %>%
  group_by(Cluster, Sex) %>%
  mutate(mean_norm_count = mean(norm_count)) %>%
  mutate(se_mean = sd(norm_count) / sqrt(36)) %>%
  drop_na()

mean_norm_count_M_M1 <- calcnums$mean_norm_count[calcnums$Sample == "WT_M_1"]
calcnums$mean_norm_count_M <- mean_norm_count_M_M1[match(calcnums$Cluster, calcnums$Cluster)]

calcnums <- calcnums %>%
  mutate(norm_count_normalizedtoM = ((norm_count / mean_norm_count_M) - 1)) %>%
  drop_na()

# Make sure the M mean is around 0
calcnums %>%
  filter(Sex == "M") %>%
  group_by(Cluster) %>%
  summarize(mean = mean(norm_count_normalizedtoM))

calcnums <- calcnums %>%
  group_by(Cluster, Sex) %>%
  mutate(mean_norm_count_normalizedtoM = mean(norm_count_normalizedtoM)) %>%
  mutate(se_mean_norm_count_normalizedtoM = sd(norm_count_normalizedtoM) / sqrt(36)) %>%
  drop_na()

calcnums <- calcnums %>%
  group_by(Cluster, Sex) %>%
  mutate(mean_normtoM_pct = mean_norm_count_normalizedtoM * 100) %>%
  mutate(se_mean_normtoM_pct = se_mean_norm_count_normalizedtoM * 100) %>%
  drop_na()

cluster_order <- rev(sort(levels(wt_only)))
calcnums$Sex <- factor(calcnums$Sex, levels = c("M", "F"))
```

```{r bar plot props by sex}
p1 <- ggplot(calcnums, aes(x = mean_norm_count, y = Cluster, fill = Sex)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Proportion", y = "Cluster") +
  theme_classic() +
  scale_fill_manual(values = palette_sex) +
  scale_x_continuous(limits = c(0, 0.05)) +
  theme(
    legend.position = "none",
    axis.text.y = element_text(color = rep(c("#000000", "#555555"),
      length.out = length(unique(calcnums$Cluster))
    ))
  )

p2 <- ggplot(calcnums, aes(x = mean_norm_count_normalizedtoM, y = Cluster, fill = Sex)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count_normalizedtoM - se_mean_norm_count_normalizedtoM, xmax = mean_norm_count_normalizedtoM + se_mean_norm_count_normalizedtoM),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_sex) +
  theme(
    axis.text.y = element_blank(),
    legend.position = "none"
  )

p4 <- ggplot(calcnums, aes(x = mean_normtoM_pct, y = Cluster, fill = Sex)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_normtoM_pct - se_mean_normtoM_pct, xmax = mean_normtoM_pct + se_mean_normtoM_pct),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Percent change in proportion") +
  theme_classic() +
  scale_fill_manual(values = palette_sex) +
  theme(
    axis.text.y = element_blank(),
    legend.position = "right"
  )

wrap_plots(p1, p2, p4)
ggsave("../../results/proportions_WTonly/intermed-figs/250301_proportionsbySex_1-5_5pct_res1.8_50dims_neuronal.png",
  device = png,
  width = 12,
  height = 8
)
```

```{r propeller by sex}
props.sex <- propeller(clusters = wt_only@meta.data$cell_type, sample = wt_only$sample, group = wt_only$sex, transform = "logit")

write.csv(props.sex, file = "../../results/proportions_WTonly/250301_props_Sex_1-5_5pct_res1.8_50dims_neuronal.csv", row.names = TRUE)
props.sex
```

#### adding cells and genes to plot
```{r selecting sig clusters from props analysis}
# Filter the data frame for P.Value < 0.051
significant_clusters <- props.sex[props.sex$FDR < 0.05, ]

# Extract the BaselineProp.clusters for the significant results
significant_cluster_names <- sort(as.character(significant_clusters$BaselineProp.clusters))

# Print the list of significant clusters
print(significant_cluster_names)
```

```{r cells and genes plot for sig clusters sex}
# Create a data frame for the significant clusters
sig_cellsgenes_df <- cellsgenes_df %>%
  dplyr::filter(Cluster %in% significant_cluster_names) %>%
  arrange(match(Cluster, significant_cluster_names))

# Ensure Cluster is a factor with levels in the correct order
sig_cellsgenes_df$Cluster <- factor(sig_cellsgenes_df$Cluster, levels = rev(significant_cluster_names))

cells <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = CellsPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = CellsPerCluster)) +
  scale_fill_gradient2(
    low = "#757575",
    mid = "#9E9E9E",
    high = "#FAFAFA",
    midpoint = 2000
  ) +
  ylab("") +
  xlab("Nuclei") +
  theme_classic() +
  scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(
    axis.text.x = element_blank(),
    legend.position = "none",
    axis.text.y = element_text(color = rep(c("#000000", "#555555"),
      length.out = length(unique(calcnums$Cluster))
    ))
  )

genes <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = GenesPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = GenesPerCluster)) +
  scale_fill_gradient2(
    low = "#757575",
    mid = "#9E9E9E",
    high = "#FAFAFA",
    midpoint = 19000
  ) +
  ylab("") +
  xlab("Genes") +
  theme_classic() +
  scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    legend.position = "none"
  )

wrap_plots(cells, genes)
```

```{r bar plot sig clusters only sex}
sig_calcnums <- calcnums %>%
  dplyr::filter(Cluster %in% significant_cluster_names) %>%
  arrange(match(Cluster, significant_cluster_names))


sig_calcnums$Cluster <- factor(sig_calcnums$Cluster, levels = rev(significant_cluster_names))

sig_p1 <- ggplot(sig_calcnums, aes(x = mean_norm_count, y = Cluster, fill = Sex)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_point(aes(x = norm_count, y = Cluster),
    position = position_dodge(width = 0.7),
    color = "black",
    size = 0.01
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_sex) +
  scale_x_continuous(limits = c(0, 0.1)) +
  theme(
    legend.position = "right",
    axis.text.y = element_blank()
  )

sig_p1
```

```{r save wrapped plots sex}
wrap_plots(cells, genes, sig_p1, nrow = 1)

ggsave("../../results/proportions_WTonly/250301_propsandDEGsbySex_sigonly.pdf",
  device = pdf,
 width = 20,
 height = 4
)
```

### props diff. by Region
```{r add region to props df sex}
anatomical_dict <- c(
  "TH Prkcd Grin2c Glut_1" = "Other",
  "TH Prkcd Grin2c Glut_2" = "Other",
  "TH Prkcd Grin2c Glut_3" = "Other",
  "TH Prkcd Grin2c Glut_4" = "Other",
  "AV Col27a1 Glut" = "Other",
  "TH Prkcd Grin2c Glut_5" = "Other",
  "TH Prkcd Grin2c Glut_6" = "Other",
  "TH Prkcd Grin2c Glut_7" = "Other",
  "RE-Xi Nox4 Glut" = "Other",
  "TH-PVT-RE Ntrk1-Nox4 Glut" = "Other",
  "TH Sema5b-Ntrk Glut" = "Other",
  "AD Serpinb7 Glut" = "Other",
  "HY NSCs_1" = "Hypothalamus",
  "Chat GABA" = "Hypothalamus",
  "STR-PAL Chst9 Gaba" = "Other",
  "Mixed" = "Hypothalamus",
  "VMH Nr5a1 Glut_1" = "Hypothalamus",
  "Lhx6-Lhx8 Gaba" = "Hypothalamus",
  "Lhx6 Gaba" = "Hypothalamus",
  "PH-LHA-MM Foxb1 Glut" = "Hypothalamus",
  "PV-PT Ntrk1-Sp9 Glut" = "Other",
  "PO-MEA Glut" = "Hypothalamus",
  "PO-COAa-PAA-MEA Barhl2 Glut" = "Hypothalamus",
  "VMH Nr5a1 Glut_2" = "Hypothalamus",
  "DMH Hmx2-Vgll1 Glut" = "Hypothalamus",
  "TU-ARH Otp Six6 Gaba" = "Hypothalamus",
  "DMH Gaba" = "Hypothalamus",
  "ZI-PVH-SBPV Pax6-Prox1 Gaba" = "Other",
  "AHN Onecut3 Gaba" = "Hypothalamus",
  "AHN-PVHd-PVR Mixed Gaba" = "Hypothalamus",
  "PVpo-VMPO-MPN Hmx2 Gaba" = "Hypothalamus",
  "PO-CEA-BST Meis2 Gaba" = "Hypothalamus",
  "PO-MEA-BST Mixed Gaba" = "Hypothalamus",
  "LHA Pmch Glut" = "Hypothalamus",
  "Pitx2 Glut" = "Hypothalamus",
  "Trh Glut" = "Hypothalamus",
  "PH-LHA-PVH-SO-PVa Nxph4 Glut" = "Hypothalamus",
  "RT-ZI Gnb3 Gaba_1" = "Other",
  "GPi Tbr1 Cngb3 Gaba-Glut" = "Other",
  "SI-MA-LPO-LHA Skor1 Glut" = "Hypothalamus",
  "ADP-MPO Trp73 Glut" = "Hypothalamus",
  "SCsg Gabrr2 Gaba" = "Other",
  "ZI Mixed Gaba" = "Other",
  "ZI Pax6 Gaba" = "Other",
  "GPe-SI Sox6 Cyp26b1 Gaba" = "Other",
  "NDB-SI-MA-STRv Lhx8 Gaba" = "Hypothalamus",
  "SI-MPO-LPO-ADP Lhx8 Gaba" = "Hypothalamus",
  "HY NSCs_2" = "Hypothalamus",
  "STR D1-D2 Gaba" = "Other",
  "STR D1 Gaba" = "Other",
  "PO-MEA Slc17a7 Glut" = "Hypothalamus",
  "ARC Mixed Glut" = "Hypothalamus",
  "PVN Mixed Glut" = "Hypothalamus",
  "PF Fzd5 Glut" = "Other",
  "LH-MH Glut" = "Hypothalamus",
  "STN-PSTN Pitx2 Glut" = "Other",
  "SNc-VTA-RAmb Foxa1 Dopa" = "Other",
  "RT-ZI Gnb3 Gaba_2" = "Other",
  "PVH-SO-PVa Avp Glut" = "Hypothalamus",
  "PVH-SO-PVa Agtr1a Glut" = "Hypothalamus",
  "TRS-BAC Sln Glut" = "Hypothalamus",
  "Hist Gaba" = "Hypothalamus",
  "Mixed Meis2 Gaba" = "Hypothalamus",
  "TH Prkcd Grin2c Glut_8" = "Other",
  "SCH Six6 Cdc14a Gaba" = "Hypothalamus"
)
props.sex$region <- anatomical_dict[as.character(props.sex$BaselineProp.clusters)]
props.sex <- props.sex %>%
  dplyr::arrange(region, FDR)
props.sex <- props.sex[order(props.sex$region, props.sex$FDR, decreasing = TRUE), ]
```

```{r p-values by region plot sex}
n_clusters <- length(unique(props.sex$BaselineProp.clusters))
text_colors <- rep(c("#000000", "#555555"), length.out = n_clusters)

ggplot(props.sex, aes(
  x = -log10(FDR),
  y = factor(BaselineProp.clusters,
    levels = unique(props.sex$BaselineProp.clusters)
  ),
  color = region
)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(
    x = "-log10(P-value) FDR adj.",
    y = "Cluster",
    title = "Sex differences in cluster proportions"
  ) +
  theme(
    axis.text.y = element_text(
      size = 8,
      color = rev(text_colors)
    ), # rev() to match the order of clusters
    legend.position = "right"
  )

ggsave(
  filename = "../../results/proportions_WTonly/intermed-figs/250301_sexdiff_pvalues_hypovother.pdf",
  width = 12,
  height = 12,
  dpi = 300
)
```

```{r p-values by region plot sex top 10}
filtered_props <- props.sex %>%
  group_by(region) %>%
  arrange(FDR) %>%
  slice_head(n = 10) %>%
  ungroup() %>%
  arrange(rev(region))

# Then use the filtered data in your plot
ggplot(filtered_props, aes(
  x = -log10(FDR),
  y = factor(BaselineProp.clusters,
    levels = unique(filtered_props$BaselineProp.clusters)
  ),
  color = region
)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(
    x = "-log10(P-value) FDR adj.",
    y = "Cluster",
    title = "Sex differences in cluster proportions"
  ) +
  theme(
    axis.text.y = element_text(
      size = 8,
      color = rev(text_colors)[1:nrow(filtered_props)]
    ), # adjust colors to match filtered data
    legend.position = "right",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.line.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.y = element_line(color = "black")
  )


ggsave(
  filename = "../../results/proportions_WTonly/250301_sexdiff_pvalues_hypovother.pdf",
  width = 8,
  height = 12,
  dpi = 300
)
```

```{r Fisher's for props significance by region}
# Create contingency table of significant vs non-significant clusters by region
props.sex$significant <- props.sex$FDR < 0.05

# Create contingency table
cont_table <- with(props.sex, table(region, significant))

# Print the contingency table
print("Number of clusters by region and significance:")
print(cont_table)

# Run Fisher's exact test
fisher_result <- fisher.test(cont_table)

# Print results
print("\nFisher's exact test results:")
print(fisher_result)

# Calculate and print percentages for easier interpretation
percentages <- prop.table(cont_table, margin = 1) * 100 # margin=1 calculates percentages within each region
print("\nPercentage of significant clusters by region:")
print(percentages[, "TRUE"])
```

## by dissector
Since two people were dissecting the brains, we want to compare to see if 
proportions differ by dissector. 
```{r load in dissector data}
dissector_data <- read.csv("../../doc/073123_Dissector_forR.csv", stringsAsFactors = FALSE)

dissector_data <- dissector_data[, apply(dissector_data, 2, function(x) {
  sum(!is.na(x)) > 0
})]

dissector_data <- subset(dissector_data, select = -c(Sac_Learner, Ever_Learner, Coded_ID))

head(dissector_data)
```

```{r add dissector to metadata}
# Merge the metadata with behavior_data
metadata <- merge(wt_only@meta.data, dissector_data, by = "sample", all.x = TRUE, sort = FALSE)

# Set the rownames of the merged metadata to the preserved rownames
rownames(metadata) <- rownames(wt_only@meta.data)

dim(metadata)
dim(wt_only@meta.data)

wt_only@meta.data <- metadata

wt_only$Dissector <- factor(wt_only$Dissector)
levels(wt_only$Dissector) <- c("Din", "Simona")
```

First let's plot UMAPs and PCAs. 
```{r umap by dissector}
DimPlot_scCustom(wt_only,
  colors_use = palette_dissector,
  group.by = "Dissector",
  reduction = "umap",
  label = FALSE,
  raster = FALSE,
  split_seurat = TRUE,
  pt.size = 0.01
) +
  theme(legend.position = "right")

ggsave(
  filename = "../../results/proportions_WTonly/250301_umap_neuronal_bydissector.png",
  width = 12,
  height = 12,
  dpi = 300
)
```

```{r pca by dissector}
DimPlot_scCustom(wt_only,
  colors_use = palette_dissector,
  group.by = "Dissector",
  reduction = "pca",
  label = FALSE,
  raster = FALSE,
  split_seurat = TRUE,
  pt.size = 0.01
) +
  theme(legend.position = "right")


ggsave(
  filename = "../../results/proportions_WTonly/intermed-figs/250301_pca_neuronal_bydissector.png",
  width = 12,
  height = 12,
  dpi = 300
)
```

```{r proprotions df with dissector}
celldistribution <- data.frame(table(wt_only@meta.data$cell_type, wt_only@meta.data$sample))
colnames(celldistribution) <- c("Cluster", "Sample", "Number")
celldistribution$Sex <- gsub(".*_(\\w)_.*", "\\1", celldistribution$Sample)
celldistribution$Genotype <- gsub("^(.*?)_.*$", "\\1", celldistribution$Sample)

celldistribution <- left_join(celldistribution,
  dissector_data[, c("sample", "Dissector")],
  by = c("Sample" = "sample")
)

celldistribution <- celldistribution %>%
  group_by(Sample) %>%
  mutate(norm_count = Number / sum(Number)) %>%
  ungroup()

celldistribution$Dissector <- factor(celldistribution$Dissector, levels = c("Din", "Simona"))

celldistribution
```

```{r df with prop means by dissector}
calcnums <- celldistribution %>%
  group_by(Cluster, Dissector) %>%
  mutate(mean_norm_count = mean(norm_count)) %>%
  mutate(se_mean = sd(norm_count) / sqrt(36)) %>%
  drop_na()

mean_norm_count_WT_M1 <- calcnums$mean_norm_count[calcnums$Sample == "WT_M_1"]
calcnums$mean_norm_count_WT <- mean_norm_count_WT_M1[match(calcnums$Cluster, calcnums$Cluster)]

calcnums <- calcnums %>%
  mutate(norm_count_normalizedtoNL = ((norm_count / mean_norm_count_WT) - 1)) %>%
  drop_na()

# Make sure the WT mean is around 0
calcnums %>%
  filter(Dissector == "Din") %>%
  group_by(Cluster) %>%
  summarize(mean = mean(norm_count_normalizedtoNL))

calcnums <- calcnums %>%
  group_by(Cluster, Dissector) %>%
  mutate(mean_norm_count_normalizedtoNL = mean(norm_count_normalizedtoNL)) %>%
  mutate(se_mean_norm_count_normalizedtoNL = sd(norm_count_normalizedtoNL) / sqrt(36)) %>%
  drop_na()

calcnums <- calcnums %>%
  group_by(Cluster, Dissector) %>%
  mutate(mean_normtoNL_pct = mean_norm_count_normalizedtoNL * 100) %>%
  mutate(se_mean_normtoNL_pct = se_mean_norm_count_normalizedtoNL * 100) %>%
  drop_na() %>%
  ungroup()

calcnums$Dissector <- factor(calcnums$Dissector, levels = c("Din", "Simona"))
calcnums
```

```{r bar plots props by dissector}
cluster_order <- sort(as.character(unique(calcnums$Cluster), decreasing = TRUE))

p1 <- ggplot(calcnums, aes(
  x = mean_norm_count,
  y = factor(Cluster, levels = rev(cluster_order)),
  fill = Dissector
)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Proportion", y = "Cluster") +
  theme_classic() +
  scale_fill_manual(values = palette_dissector) +
  scale_x_continuous(limits = c(0, 0.05)) +
  theme(
    legend.position = "none",
    axis.text.y = element_text(color = rep(c("#000000", "#555555"),
      length.out = length(unique(calcnums$Cluster))
    ))
  )

p2 <- ggplot(calcnums, aes(
  x = mean_norm_count_normalizedtoNL,
  y = factor(Cluster, levels = rev(cluster_order)), fill = Dissector
)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count_normalizedtoNL - se_mean_norm_count_normalizedtoNL, xmax = mean_norm_count_normalizedtoNL + se_mean_norm_count_normalizedtoNL),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_dissector) +
  theme(
    axis.text.y = element_blank(),
    legend.position = "none"
  )

p4 <- ggplot(calcnums, aes(
  x = mean_normtoNL_pct,
  y = factor(Cluster, levels = rev(cluster_order)), fill = Dissector
)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_normtoNL_pct - se_mean_normtoNL_pct, xmax = mean_normtoNL_pct + se_mean_normtoNL_pct),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Percent change in proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_dissector) +
  theme(
    axis.text.y = element_blank(),
    legend.position = "right"
  )

wrap_plots(p1, p2, p4)
ggsave("../../results/proportions_WTonly/intermed-figs/250301_proportionsbyDissector_1-5_5pct_res1.8_50dims_neuronal.pdf",
  device = pdf,
  width = 12,
  height = 8
)

p1
ggsave("../../results/proportions_WTonly/250301_proportionsbyDissector_1-5_5pct_res1.8_50dims_neuronal_final.pdf",
  device = pdf,
  width = 12,
  height = 8
)
```

```{r propeller by dissector}
props.dissector <- propeller(clusters = wt_only@meta.data$cell_type, sample = wt_only$sample, group = wt_only$Dissector, transform = "logit")

write.csv(props.dissector, file = "../../results/proportions_WTonly/250301_props_Dissector_neuronal_1-5_5pct_50_1.8.csv", row.names = TRUE)
props.dissector
```

## by learner
First let's look at the UMAP and PCA:
```{r umap by sex}
DimPlot_scCustom(wt_only,
  colors_use = palette_learner,
  group.by = "Sac_Learner",
  reduction = "umap",
  label = FALSE,
  raster = FALSE,
  split_seurat = TRUE,
  pt.size = 0.01
) +
  theme(legend.position = "right")

ggsave(
  filename = "../../results/proportions_WTonly/250301_umap_1-5_5pct_res1.8_50dims_neuronal_bylearner.png",
  width = 12,
  height = 12,
  dpi = 300
)
```

```{r pca by sex}
DimPlot_scCustom(wt_only,
  colors_use = palette_learner,
  group.by = "Sac_Learner",
  reduction = "pca",
  label = FALSE,
  raster = FALSE,
  split_seurat = TRUE,
  pt.size = 0.01
) +
  theme(legend.position = "right")

ggsave(
  filename = "../../results/proportions_WTonly/intermed-figs/250301_pca_1-5_5pct_res1.8_50dims_neuronal_bylearner.png",
  width = 12,
  height = 12,
  dpi = 300
)
```

```{r add learner info to df}
# map Sample to Sac_Learner
sample_to_learner <- wt_only@meta.data %>%
  dplyr::select(Sample = sample, Sac_Learner) %>%
  distinct()

# Now merge this information with your celldistribution data frame
celldistribution <- celldistribution %>%
  left_join(sample_to_learner, by = "Sample")

celldistribution <- celldistribution %>%
  mutate(Sac_Learner = ifelse(Sac_Learner == 1, "Learner",
    ifelse(Sac_Learner == 0, "Non-Learner", as.character(Sac_Learner))
  ))
```

```{r df with prop means by learner}
calcnums <- celldistribution %>%
  group_by(Cluster, Sac_Learner) %>%
  mutate(mean_norm_count = mean(norm_count)) %>%
  mutate(se_mean = sd(norm_count) / sqrt(36)) %>%
  drop_na()

mean_norm_count_NL_M10 <- calcnums$mean_norm_count[calcnums$Sample == "WT_M_10"]
calcnums$mean_norm_count_NL <- mean_norm_count_NL_M10[match(calcnums$Cluster, calcnums$Cluster)]

calcnums <- calcnums %>%
  mutate(norm_count_normalizedtoNL = ((norm_count / mean_norm_count_NL) - 1)) %>%
  drop_na()

# Make sure the NL mean is around 0
calcnums %>%
  filter(Sac_Learner == "Non_Learner") %>%
  group_by(Cluster) %>%
  summarize(mean = mean(norm_count_normalizedtoNL))

calcnums <- calcnums %>%
  group_by(Cluster, Sac_Learner) %>%
  mutate(mean_norm_count_normalizedtoNL = mean(norm_count_normalizedtoNL)) %>%
  mutate(se_mean_norm_count_normalizedtoNL = sd(norm_count_normalizedtoNL) / sqrt(36)) %>%
  drop_na()

calcnums <- calcnums %>%
  group_by(Cluster, Sac_Learner) %>%
  mutate(mean_normtoNL_pct = mean_norm_count_normalizedtoNL * 100) %>%
  mutate(se_mean_normtoNL_pct = se_mean_norm_count_normalizedtoNL * 100) %>%
  drop_na()

calcnums$Cluster <- factor(calcnums$Cluster)
```

```{r bar plot props by learner}
p1 <- ggplot(calcnums, aes(x = mean_norm_count, y = Cluster, fill = Sac_Learner)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_point(aes(x = norm_count, y = Cluster),
    position = position_dodge(width = 0.7),
    color = "black",
    size = 0.01
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Proportion", y = "Cluster") +
  theme_classic() +
  scale_fill_manual(values = palette_learner) +
  theme(legend.position = "none", axis.text.y = element_text(color = rep(c("#000000", "#555555"),
    length.out = length(unique(calcnums$Cluster))
  )))


p2 <- ggplot(calcnums, aes(x = mean_norm_count_normalizedtoNL, y = Cluster, fill = Sac_Learner)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_point(aes(x = norm_count, y = Cluster),
    position = position_dodge(width = 0.7),
    color = "black",
    size = 0.01
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count_normalizedtoNL - se_mean_norm_count_normalizedtoNL, xmax = mean_norm_count_normalizedtoNL + se_mean_norm_count_normalizedtoNL),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_learner) +
  theme(
    axis.text.y = element_blank(),
    legend.position = "none"
  )

p4 <- ggplot(calcnums, aes(x = mean_normtoNL_pct, y = Cluster, fill = Sac_Learner)) +
  geom_bar(
    stat = "identity", position = "dodge",
    width = 0.7
  ) +
  geom_point(aes(x = norm_count, y = Cluster),
    position = position_dodge(width = 0.7),
    color = "black",
    size = 0.01
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_normtoNL_pct - se_mean_normtoNL_pct, xmax = mean_normtoNL_pct + se_mean_normtoNL_pct),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Percent change in proportion", y = "") +
  theme_classic() +
  theme(axis.text.y = element_blank()) +
  scale_fill_manual(values = palette_learner)

wrap_plots(p1, p2, p4)
ggsave("../../results/proportions_WTonly/intermed-figs/250301_proportionsbyLearner_1-5_5pct_res1.8_50dims_neuronal.png",
  device = png,
  width = 12,
  height = 8
)
```

```{r propeller by learner}
props.learner <- propeller(clusters = wt_only@meta.data$cell_type, sample = wt_only$sample, group = wt_only$Sac_Learner, transform = "logit")

write.csv(props.learner, file = "../../results/proportions_WTonly/250301_props_Learner_1-5_5pct_res1.8_50dims_neuronal.csv", row.names = TRUE)
```

### adding cells and genes to props plot
```{r selecting sig clusters from props by learner}
# Filter the data frame for P.Value < 0.05
significant_clusters <- props.learner[props.learner$P.Value < 0.05, ]

# Extract the BaselineProp.clusters for the significant results
significant_cluster_names <- sort(as.character(significant_clusters$BaselineProp.clusters))

print(significant_cluster_names)
```

```{r bar plot for sig clusters learner}
calcnums_filtered <- calcnums %>%
  filter(Cluster %in% significant_cluster_names)

# Set the factor levels to match the order in significant_cluster_names
calcnums_filtered$Cluster <- factor(calcnums_filtered$Cluster, levels = rev(significant_cluster_names))

sig_p1 <- ggplot(calcnums_filtered, aes(x = mean_norm_count, y = Cluster, fill = Sac_Learner)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
    position = position_dodge(width = 0.7),
    color = "black",
    size = 0.01
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_learner) +
  theme(legend.position = "right") +
  theme(axis.text.y = element_blank())
sig_p1
```

```{r cell genes plot for sig clusters learner}
# Create a data frame for the significant clusters
sig_cellsgenes_df <- cellsgenes_df %>%
  dplyr::filter(Cluster %in% significant_cluster_names) %>%
  dplyr::arrange(match(Cluster, significant_cluster_names))

# Ensure Cluster is a factor with levels in the correct order
sig_cellsgenes_df$Cluster <- factor(sig_cellsgenes_df$Cluster, levels = rev(significant_cluster_names))

cells <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = CellsPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = CellsPerCluster)) +
  scale_fill_gradient2(
    low = "#757575",
    mid = "#9E9E9E",
    high = "#FAFAFA",
    midpoint = 2000
  ) +
  xlab("Cells") +
  ylab("") +
  theme_classic() +
  scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(
    axis.text.x = element_blank(),
    legend.position = "none",
    axis.text.y = element_text(color = rep(c("#000000", "#555555"),
      length.out =
        length(unique(calcnums$Cluster))
    ))
  )

genes <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = GenesPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = GenesPerCluster)) +
  scale_fill_gradient2(
    low = "#757575",
    mid = "#9E9E9E",
    high = "#FAFAFA",
    midpoint = 19000
  ) +
  xlab("Genes") +
  ylab("") +
  theme_classic() +
  scale_y_discrete(limits = rev(significant_cluster_names)) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    legend.position = "none"
  )

wrap_plots(cells, genes)
```

```{r save wrapped plot for learner}
wrap_plots(cells, genes, sig_p1)
ggsave("../../results/proportions_WTonly/intermed-figs/250301_propsbyLearner_sigonly.pdf",
  device = pdf,
  width = 12,
  height = 6
)
```

### adding sex as co-variate
First, let's deconstrucut propeller, according to their vignette, and make sure 
the results are the same as when running the function.
```{r propeller logit transform props}
props <- getTransformedProps(
  clusters = wt_only$cell_type,
  sample = wt_only$sample,
  transform = "logit"
)
```

```{r propeller by learner step-by-step}
# Extract var1 (Sac_Learner) from the metadata
var1 <- wt_only@meta.data$Sac_Learner

# Create a data frame with sample information
sample_info <- data.frame(
  sample = wt_only$sample,
  var1 = var1
)

# Order the sample information based on the order of samples in prop.logit
sample_info <- sample_info[match(colnames(props$TransformedProps), sample_info$sample), ]

# Create the design matrix with var1 and var2
des <- model.matrix(~var1, data = sample_info)

# Fit the linear model
fit <- lmFit(props$TransformedProps, des)

# Perform empirical Bayes shrinkage of the variances
fit <- eBayes(fit, robust = TRUE)

# and results for transformed proportions:
res <- topTable(fit, number = 76)

# Fit the model on the original proportions scale
fit.prop <- lmFit(props$Proportions, des)
fit.prop <- eBayes(fit.prop, robust = TRUE)
res.prop <- topTable(fit.prop, number = 76)

# Extract full results table for transformed proportions
res.var1 <- topTable(fit, number = Inf)

# Extract full results from original proportion analysis
res.prop.var1 <- topTable(fit.prop, number = Inf)

# Combine results for all clusters
res.combined <- data.frame(
  Cluster = rownames(res.var1),
  Sac_Learner_Coef = res.prop.var1$logFC,
  Sac_Learner_P.Value = res.var1$P.Value,
  Sac_Learner_adj.P.Val = res.var1$adj.P.Val,
  B_Sac_Learner = res.var1$B,
  AveExpr = res.var1$AveExpr
)

# Check the result
print(head(res.combined))
```
The results above should correspond entirely with the results from calling the
propeller funciton.

```{r props by learner and sex regression}
# Extract Sac_Learner and Sex from the metadata
Sac_Learner <- wt_only@meta.data$Sac_Learner
Sex <- as.factor(wt_only@meta.data$sex)

# Create a data frame with sample information
sample_info <- data.frame(
  sample = wt_only$sample,
  Sac_Learner = Sac_Learner,
  Sex = Sex
)

# Order the sample information based on the order of samples in prop.logit
sample_info <- sample_info[match(colnames(props$TransformedProps), sample_info$sample), ]

# Create the design matrix
des <- model.matrix(~ Sac_Learner + Sex, data = sample_info)

# Fit the linear model
fit <- lmFit(props$TransformedProps, des)

# Perform empirical Bayes shrinkage of the variances
fit <- eBayes(fit, robust = TRUE)

# and results for transformed proportions:
res <- topTable(fit, number = 76)

# Fit the model on the original proportions scale
fit.prop <- lmFit(props$Proportions, des)
fit.prop <- eBayes(fit.prop, robust = TRUE)
res.prop <- topTable(fit.prop, number = 76)
```

```{r props by learner and sex table and save}
# Extract full results table for transformed proportions
res.sac_learner <- topTable(fit, number = Inf, coef = c("Sac_LearnerNon_Learner"))
res.sex <- topTable(fit, number = Inf, coef = c("SexM"))

# Extract full results from original proportion analysis
res.prop.sac_learner <- topTable(fit.prop, number = Inf, coef = c("Sac_LearnerNon_Learner"))
res.prop.sex <- topTable(fit.prop, number = Inf, coef = c("SexM"))

# Combine results for all clusters
res.combined <- data.frame(
  Cluster = rownames(res.sac_learner),
  Sac_Learner_Coef = res.prop.sac_learner$logFC,
  Sac_Learner_P.Value = res.sac_learner$P.Value,
  Sac_Learner_adj.P.Val = res.sac_learner$adj.P.Val,
  B_Sac_Learner = res.sac_learner$B,
  Sac_Learner_Ratio = 2^res.prop.sac_learner$logFC, # Add this line
  Sex_Coef = res.prop.sex$logFC,
  Sex_P.Value = res.sex$P.Value,
  Sex_adj.P.Val = res.sex$adj.P.Val,
  B_Sex = res.sex$B,
  Sex_Ratio = 2^res.prop.sex$logFC, # Add this line
  AveExpr = res.sac_learner$AveExpr # AveExpr should be the same for both
)

# Get untransformed proportions
props_matrix <- props$Proportions

# Ensure sample_info is ordered correctly
sample_info <- sample_info[match(colnames(props_matrix), sample_info$sample), ]

# Convert props_matrix to a regular matrix
props_matrix <- as.matrix(props_matrix)

# Calculate mean proportions for each group
learner_means <- rowMeans(props_matrix[, sample_info$Sac_Learner == "Learner", drop = FALSE])
non_learner_means <- rowMeans(props_matrix[, sample_info$Sac_Learner == "Non_Learner", drop = FALSE])
male_means <- rowMeans(props_matrix[, sample_info$Sex == "M", drop = FALSE])
female_means <- rowMeans(props_matrix[, sample_info$Sex == "F", drop = FALSE])


# Add mean proportions to the results
res.combined$PropMean_Learner <- learner_means[res.combined$Cluster]
res.combined$PropMean_NonLearner <- non_learner_means[res.combined$Cluster]
res.combined$PropMean_Male <- male_means[res.combined$Cluster]
res.combined$PropMean_Female <- female_means[res.combined$Cluster]

# Calculate direct ratios
res.combined$Direct_Ratio_Learner_NonLearner <- res.combined$PropMean_Learner / res.combined$PropMean_NonLearner
res.combined$Direct_Ratio_Male_Female <- res.combined$PropMean_Male / res.combined$PropMean_Female

# Check the result
head(res.combined)

# Write to CSV
write.csv(res.combined,
  file = "../../results/proportions_WTonly/250301_props_Learner_Sex_neuronal_1-5_5pct_50dims.csv",
  row.names = FALSE
)
```

### props diff. by Region
```{r add region to props df learner}
props.learner$region <- anatomical_dict[props.learner$BaselineProp.clusters]
props.learner <- props.learner %>%
  dplyr::arrange(region, FDR)
props.learner <- props.learner[order(props.learner$region, props.learner$FDR, decreasing = TRUE), ]
```

```{r p-values by region plot learner}
n_clusters <- length(unique(props.learner$BaselineProp.clusters))
text_colors <- rep(c("#000000", "#555555"), length.out = n_clusters)

ggplot(props.learner, aes(
  x = -log10(FDR),
  y = factor(BaselineProp.clusters,
    levels = unique(props.learner$BaselineProp.clusters)
  ),
  color = region
)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(
    x = "-log10(P-value)",
    y = "Cluster",
    title = "Learner differences in cluster proportions"
  ) +
  theme(
    axis.text.y = element_text(
      size = 8,
      color = rev(text_colors)
    ), # rev() to match the order of clusters
    legend.position = "right"
  )

ggsave(
  filename = "../../results/proportions_WTonly/intermed-figs/250301_learnerprops_pvalues_hypovother.pdf",
  width = 12,
  height = 12,
  dpi = 300
)
```

```{r p-values by region plot learner top 10}
filtered_props <- props.learner %>%
  group_by(region) %>%
  arrange(FDR) %>%
  slice_head(n = 18) %>%
  ungroup() %>%
  arrange(rev(region))

filtered_props <- filtered_props[order(filtered_props$region, filtered_props$FDR, decreasing = TRUE), ]

# Then use the filtered data in your plot
ggplot(filtered_props, aes(
  x = -log10(FDR),
  y = factor(BaselineProp.clusters,
    levels = unique(filtered_props$BaselineProp.clusters)
  ),
  color = region
)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(
    x = "-log10(P-value)",
    y = "Cluster",
    title = "Learner differences in cluster proportions"
  ) +
  theme(
    axis.text.y = element_text(
      size = 8,
      color = rev(text_colors)[1:nrow(filtered_props)]
    ), # adjust colors to match filtered data
    legend.position = "right",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.line.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.y = element_line(color = "black")
  )

ggsave(
  filename = "../../results/proportions_WTonly/intermed-figs/250301_learnerprops_pvalues_hypovother.pdf",
  width = 6,
  height = 8,
  dpi = 300
)
```

```{r Fisher's for props significance by region}
# Create contingency table of significant vs non-significant clusters by region
props.learner$significant <- props.learner$P.Value < 0.05

# Create contingency table
cont_table <- with(props.learner, table(region, significant))

# Print the contingency table
print("Number of clusters by region and significance:")
print(cont_table)

# Run Fisher's exact test
fisher_result <- fisher.test(cont_table)

# Print results
print("\nFisher's exact test results:")
print(fisher_result)

# Calculate and print percentages for easier interpretation
percentages <- prop.table(cont_table, margin = 1) * 100 # margin=1 calculates percentages within each region
print("\nPercentage of significant clusters by region:")
print(percentages[, "TRUE"])
```

# Rewards by props

```{r propeller logit transform props}
# Extract the cell type proportions and transform them
props <- getTransformedProps(
  cluster = wt_only$cell_type,
  sample = wt_only$sample,
  transform = "logit"
)

head(props$TransformedProps)

# Convert props$TransformedProps to a data frame
props_df <- as.data.frame(props$TransformedProps)

names(props_df)[names(props_df) == "Freq"] <- "props_trans"

head(props_df)
str(props_df)
```

```{r merge with sample metadata}
# Create a data frame with sample information
sample_info <- data.frame(
  sample = wt_only$sample,
  distance = wt_only$Avg_Test_Distance,
  rewards = wt_only$Avg_Total_Rewards,
  time = wt_only$Avg_Exp_Zone_Time,
  entries = wt_only$Avg_Exp_Zone_Entries,
  clusters = wt_only$cell_type,
  geno = wt_only$genotype,
  sex = wt_only$sex,
  learner = wt_only$Sac_Learner
)

head(sample_info)
str(sample_info)
```


```{r make a merged df for analysis}
merged_df <- merge(props_df, sample_info, by = c("sample", "clusters"))
rownames(merged_df) <- rownames(sample_info)

# Print the first few rows of the merged data
head(merged_df)
str(merged_df)
```

```{r linear regression rewards by props}
# Create an empty data frame to store the results
model_summary_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Fit the linear regression model
  lm_model <- lm(rewards ~ props_trans, data = cluster_df)

  # Extract the model summary
  model_summary <- summary(lm_model)

  # Create a named vector with model summary statistics
  model_summary_vec <- c(
    `(Intercept)` = coef(lm_model)[1],
    `(Intercept) p-value` = coef(model_summary)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model)[2],
    `Props Std. Error` = coef(model_summary)[2, "Std. Error"],
    `Props t value` = coef(model_summary)[2, "t value"],
    `Props p-value` = coef(model_summary)[2, "Pr(>|t|)"],
    r_squared = model_summary$r.squared,
    adj_r_squared = model_summary$adj.r.squared,
    f_statistic = model_summary$fstatistic[1],
    f_pvalue = pf(model_summary$fstatistic[1], model_summary$fstatistic[2], model_summary$fstatistic[3], lower.tail = FALSE)
  )

  # Convert the named vector to a data frame
  model_summary_vec_df <- data.frame(t(model_summary_vec))

  # Add a column for the cluster
  model_summary_vec_df$cluster <- cluster

  # Append the data frame to the overall result
  model_summary_df <- rbind(model_summary_df, model_summary_vec_df)
}

# Extract the 'Props p-value' column
props_pvalues <- model_summary_df$Props.p.value

# Perform BH adjustment
bh_adjusted_pvalues <- p.adjust(props_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
model_summary_df$bh_adjusted_pvalues <- bh_adjusted_pvalues

model_summary_df %>%
  ungroup() %>%
  arrange(bh_adjusted_pvalues)

# Print the resulting data frame
model_summary_df

write.csv(model_summary_df, file = "../../results/proportions_WTonly/250301_rewardsbyprops.csv")
```

## . with Sex
```{r linear regression rewards by props and sex}
# Slightly modified to handle clusters with only one level of sex
# Create an empty data frame to store the results
model_summary_sex_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Check if the cluster has more than one sex level
  if (n_distinct(cluster_df$sex) > 1) {
    # Fit the linear regression model with sex added
    tryCatch(
      {
        lm_model_sex <- lm(rewards ~ props_trans + sex, data = cluster_df)

        # Extract the model summary
        model_summary_sex <- summary(lm_model_sex)

        # Create a named vector with model summary statistics
        model_summary_vec_sex <- c(
          `(Intercept)` = coef(lm_model_sex)[1],
          `(Intercept) p-value` = coef(model_summary_sex)[1, "Pr(>|t|)"],
          `Props` = coef(lm_model_sex)[2],
          `Props Std. Error` = coef(model_summary_sex)[2, "Std. Error"],
          `Props t value` = coef(model_summary_sex)[2, "t value"],
          `Props p-value` = coef(model_summary_sex)[2, "Pr(>|t|)"],
          `Sex` = coef(lm_model_sex)[3],
          `Sex Std. Error` = coef(model_summary_sex)[3, "Std. Error"],
          `Sex t value` = coef(model_summary_sex)[3, "t value"],
          `Sex p-value` = coef(model_summary_sex)[3, "Pr(>|t|)"],
          r_squared = model_summary_sex$r.squared,
          adj_r_squared = model_summary_sex$adj.r.squared,
          f_statistic = model_summary_sex$fstatistic[1],
          f_pvalue = pf(model_summary_sex$fstatistic[1], model_summary_sex$fstatistic[2], model_summary_sex$fstatistic[3], lower.tail = FALSE)
        )

        # Convert the named vector to a data frame
        model_summary_vec_sex_df <- data.frame(t(model_summary_vec_sex))

        # Add a column for the cluster
        model_summary_vec_sex_df$cluster <- cluster

        # Append the data frame to the overall result
        model_summary_sex_df <- rbind(model_summary_sex_df, model_summary_vec_sex_df)
      },
      error = function(e) {
        # If an error occurs, print it and continue
        cat("Error in cluster", cluster, ":", e$message, "\n")
      }
    )
  } else {
    # Print a message for clusters with only one sex level
    cat("Skipping cluster '", cluster, "' - only one sex level present\n", sep = "")
  }
}
# If there are results to process
if (nrow(model_summary_sex_df) > 0) {
  # Extract the 'Props p-value' column
  props_pvalues <- model_summary_sex_df$Props.p.value
  sex_pvalues <- model_summary_sex_df$Sex.p.value

  # Perform BH adjustment
  bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
  bh_adjusted_pvalues_sex <- p.adjust(sex_pvalues, method = "BH")

  # Add the BH-adjusted p-values to the data frame
  model_summary_sex_df$bh_pvalues_props <- bh_adjusted_pvalues_props
  model_summary_sex_df$bh_pvalues_sex <- bh_adjusted_pvalues_sex

  # Sort and print the results
  sorted_results <- model_summary_sex_df %>%
    ungroup() %>%
    arrange(bh_pvalues_props)

  print(sorted_results)
} else {
  cat("No clusters had sufficient variation in the sex variable to fit models.\n")
}

# Write the data frame to a CSV file
write.csv(model_summary_sex_df, file = "../../results/proportions_WTonly/250301_rewardsbyprops_sex.csv")
```

## . with Learner
```{r linear regression rewards by props and learner}
# Slightly modified to handle clusters with only one level of sex
# Create an empty data frame to store the results
model_summary_learner_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Check if the cluster has more than one learner level
  if (n_distinct(cluster_df$learner) > 1) {
    # Fit the linear regression model with learner added
    tryCatch(
      {
        lm_model_learner <- lm(rewards ~ props_trans + learner, data = cluster_df)

        # Extract the model summary
        model_summary_learner <- summary(lm_model_learner)

        # Create a named vector with model summary statistics
        model_summary_vec_learner <- c(
          `(Intercept)` = coef(lm_model_learner)[1],
          `(Intercept) p-value` = coef(model_summary_learner)[1, "Pr(>|t|)"],
          `Props` = coef(lm_model_learner)[2],
          `Props Std. Error` = coef(model_summary_learner)[2, "Std. Error"],
          `Props t value` = coef(model_summary_learner)[2, "t value"],
          `Props p-value` = coef(model_summary_learner)[2, "Pr(>|t|)"],
          `learner` = coef(lm_model_learner)[3],
          `learner Std. Error` = coef(model_summary_learner)[3, "Std. Error"],
          `learner t value` = coef(model_summary_learner)[3, "t value"],
          `learner p-value` = coef(model_summary_learner)[3, "Pr(>|t|)"],
          r_squared = model_summary_learner$r.squared,
          adj_r_squared = model_summary_learner$adj.r.squared,
          f_statistic = model_summary_learner$fstatistic[1],
          f_pvalue = pf(model_summary_learner$fstatistic[1], model_summary_learner$fstatistic[2], model_summary_learner$fstatistic[3], lower.tail = FALSE)
        )

        # Convert the named vector to a data frame
        model_summary_vec_learner_df <- data.frame(t(model_summary_vec_learner))

        # Add a column for the cluster
        model_summary_vec_learner_df$cluster <- cluster

        # Append the data frame to the overall result
        model_summary_learner_df <- rbind(model_summary_learner_df, model_summary_vec_learner_df)
      },
      error = function(e) {
        # If an error occurs, print it and continue
        cat("Error in cluster", cluster, ":", e$message, "\n")
      }
    )
  } else {
    # Print a message for clusters with only one learner level
    cat("Skipping cluster '", cluster, "' - only one learner level present\n", sep = "")
  }
}

# If there are results to process
if (nrow(model_summary_learner_df) > 0) {
  # Extract the 'Props p-value' column
  props_pvalues <- model_summary_learner_df$Props.p.value
  learner_pvalues <- model_summary_learner_df$learner.p.value

  # Perform BH adjustment
  bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
  bh_adjusted_pvalues_learner <- p.adjust(learner_pvalues, method = "BH")

  # Add the BH-adjusted p-values to the data frame
  model_summary_learner_df$bh_pvalues_props <- bh_adjusted_pvalues_props
  model_summary_learner_df$bh_pvalues_learner <- bh_adjusted_pvalues_learner

  # Sort and print the results
  sorted_results <- model_summary_learner_df %>%
    ungroup() %>%
    arrange(bh_pvalues_props)

  print(sorted_results)
} else {
  cat("No clusters had sufficient variation in the learner variable to fit models.\n")
}

model_summary_learner_df

# Write the data frame to a CSV file
write.csv(model_summary_learner_df, file = "../../results/proportions_WTonly/intermed-tables/250301_rewardsbyprops_learner.csv")
```

## Untransformed props
Checking to see that transforming the proportions (per propeller) isn't changing 
the results, and getting untransformed props for plotting.
```{r df with untransformed props}
unprops_df <- as.data.frame(props$Proportions)

names(unprops_df)[names(unprops_df) == "Freq"] <- "props_untrans"

head(unprops_df)
str(unprops_df)

new_merged_df <- merge(unprops_df, sample_info, by = c("sample", "clusters"))
# rownames(merged_df) <- rownames(sample_info)

# Print the first few rows of the merged data
head(new_merged_df)
str(new_merged_df)
```

```{r linear regression rewards by untransformed props}
# Create an empty data frame to store the results
new_model_summary_df <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Fit the linear regression model
  lm_model <- lm(rewards ~ props_untrans, data = cluster_df)

  # Extract the model summary
  new_model_summary <- summary(lm_model)

  # Create a named vector with model summary statistics
  new_model_summary_vec <- c(
    `(Intercept)` = coef(lm_model)[1],
    `(Intercept) p-value` = coef(new_model_summary)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model)[2],
    `Props Std. Error` = coef(new_model_summary)[2, "Std. Error"],
    `Props t value` = coef(new_model_summary)[2, "t value"],
    `Props p-value` = coef(new_model_summary)[2, "Pr(>|t|)"],
    r_squared = new_model_summary$r.squared,
    adj_r_squared = new_model_summary$adj.r.squared,
    f_statistic = new_model_summary$fstatistic[1],
    f_pvalue = pf(new_model_summary$fstatistic[1], new_model_summary$fstatistic[2], new_model_summary$fstatistic[3], lower.tail = FALSE)
  )

  # Convert the named vector to a data frame
  new_model_summary_vec_df <- data.frame(t(new_model_summary_vec))

  # Add a column for the cluster
  new_model_summary_vec_df$cluster <- cluster

  # Append the data frame to the overall result
  new_model_summary_df <- rbind(new_model_summary_df, new_model_summary_vec_df)
}

# Extract the 'Props p-value' column
props_pvalues <- new_model_summary_df$Props.p.value

# Perform BH adjustment
bh_adjusted_pvalues <- p.adjust(props_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
new_model_summary_df$bh_adjusted_pvalues <- bh_adjusted_pvalues

arrange(new_model_summary_df, new_model_summary_df$bh_adjusted_pvalues)

# Print the resulting data frame
new_model_summary_df

write.csv(new_model_summary_df, file = "../../results/proportions_WTonly/intermed-tables/250301_rewardsbyprops_untransformed.csv")
```

```{r linear regression rewards by untransformed props and sex}
# Modified to handle clusters wiht only one level of sex
new_model_summary_df_sex <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Check if the cluster has more than one sex level
  if (n_distinct(cluster_df$sex) > 1) {
    # Fit the linear regression model with sex added
    tryCatch(
      {
        lm_model_sex <- lm(rewards ~ props_untrans + sex, data = cluster_df)

        # Extract the model summary
        new_model_summary_sex <- summary(lm_model_sex)

        # Create a named vector with model summary statistics
        new_model_summary_vec_sex <- c(
          `(Intercept)` = coef(lm_model_sex)[1],
          `(Intercept) p-value` = coef(new_model_summary_sex)[1, "Pr(>|t|)"],
          `Props` = coef(lm_model_sex)[2],
          `Props Std. Error` = coef(new_model_summary_sex)[2, "Std. Error"],
          `Props t value` = coef(new_model_summary_sex)[2, "t value"],
          `Props p-value` = coef(new_model_summary_sex)[2, "Pr(>|t|)"],
          `Sex` = coef(lm_model_sex)[3],
          `Sex Std. Error` = coef(new_model_summary_sex)[3, "Std. Error"],
          `Sex t value` = coef(new_model_summary_sex)[3, "t value"],
          `Sex p-value` = coef(new_model_summary_sex)[3, "Pr(>|t|)"],
          r_squared = new_model_summary_sex$r.squared,
          adj_r_squared = new_model_summary_sex$adj.r.squared,
          f_statistic = new_model_summary_sex$fstatistic[1],
          f_pvalue = pf(new_model_summary_sex$fstatistic[1], new_model_summary_sex$fstatistic[2], new_model_summary_sex$fstatistic[3], lower.tail = FALSE)
        )

        # Convert the named vector to a data frame
        new_model_summary_vec_sex_df <- data.frame(t(new_model_summary_vec_sex))

        # Add a column for the cluster
        new_model_summary_vec_sex_df$cluster <- cluster

        # Append the data frame to the overall result
        new_model_summary_df_sex <- rbind(new_model_summary_df_sex, new_model_summary_vec_sex_df)
      },
      error = function(e) {
        # If an error occurs, print it and continue
        cat("Error in cluster", cluster, ":", e$message, "\n")
      }
    )
  } else {
    # Print a message for clusters with only one sex level
    cat("Skipping cluster '", cluster, "' - only one sex level present\n", sep = "")
  }
}

# If there are results to process
if (nrow(new_model_summary_df_sex) > 0) {
  # Extract the 'Props p-value' column
  props_pvalues <- new_model_summary_df_sex$Props.p.value
  sex_pvalues <- new_model_summary_df_sex$Sex.p.value

  # Perform BH adjustment
  bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
  bh_adjusted_pvalues_sex <- p.adjust(sex_pvalues, method = "BH")

  # Add the BH-adjusted p-values to the data frame
  new_model_summary_df_sex$bh_pvalues_props <- bh_adjusted_pvalues_props
  new_model_summary_df_sex$bh_pvalues_sex <- bh_adjusted_pvalues_sex

  # Arrange the data frame by the BH-adjusted p-values
  sorted_results <- arrange(new_model_summary_df_sex, bh_pvalues_props)

  print(sorted_results)
} else {
  cat("No clusters had sufficient variation in the sex variable to fit models.\n")
}

# Write the data frame to a CSV file
write.csv(new_model_summary_df_sex, file = "../../results/proportions_WTonly/intermed-tables/250301_rewardsbypropsandsex_untransformed.csv")
```

```{r linear regression rewards by untransformed props and learner}
# Modified to handle clusters with only one level for learner
# Create an empty data frame to store the results
new_model_summary_df_learner <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Check if the cluster has more than one learner level
  if (n_distinct(cluster_df$learner) > 1) {
    # Fit the linear regression model with learner added
    tryCatch(
      {
        lm_model_learner <- lm(rewards ~ props_untrans + learner, data = cluster_df)

        # Extract the model summary
        new_model_summary_learner <- summary(lm_model_learner)

        # Create a named vector with model summary statistics
        new_model_summary_vec_learner <- c(
          `(Intercept)` = coef(lm_model_learner)[1],
          `(Intercept) p-value` = coef(new_model_summary_learner)[1, "Pr(>|t|)"],
          `Props` = coef(lm_model_learner)[2],
          `Props Std. Error` = coef(new_model_summary_learner)[2, "Std. Error"],
          `Props t value` = coef(new_model_summary_learner)[2, "t value"],
          `Props p-value` = coef(new_model_summary_learner)[2, "Pr(>|t|)"],
          `learner` = coef(lm_model_learner)[3],
          `learner Std. Error` = coef(new_model_summary_learner)[3, "Std. Error"],
          `learner t value` = coef(new_model_summary_learner)[3, "t value"],
          `learner p-value` = coef(new_model_summary_learner)[3, "Pr(>|t|)"],
          r_squared = new_model_summary_learner$r.squared,
          adj_r_squared = new_model_summary_learner$adj.r.squared,
          f_statistic = new_model_summary_learner$fstatistic[1],
          f_pvalue = pf(new_model_summary_learner$fstatistic[1], new_model_summary_learner$fstatistic[2], new_model_summary_learner$fstatistic[3], lower.tail = FALSE)
        )

        # Convert the named vector to a data frame
        new_model_summary_vec_learner_df <- data.frame(t(new_model_summary_vec_learner))

        # Add a column for the cluster
        new_model_summary_vec_learner_df$cluster <- cluster

        # Append the data frame to the overall result
        new_model_summary_df_learner <- rbind(new_model_summary_df_learner, new_model_summary_vec_learner_df)
      },
      error = function(e) {
        # If an error occurs, print it and continue
        cat("Error in cluster", cluster, ":", e$message, "\n")
      }
    )
  } else {
    # Print a message for clusters with only one learner level
    cat("Skipping cluster '", cluster, "' - only one learner level present\n", sep = "")
  }
}

# If there are results to process
if (nrow(new_model_summary_df_learner) > 0) {
  # Extract the 'Props p-value' column
  props_pvalues <- new_model_summary_df_learner$Props.p.value
  learner_pvalues <- new_model_summary_df_learner$learner.p.value

  # Perform BH adjustment
  bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
  bh_adjusted_pvalues_learner <- p.adjust(learner_pvalues, method = "BH")

  # Add the BH-adjusted p-values to the data frame
  new_model_summary_df_learner$bh_pvalues_props <- bh_adjusted_pvalues_props
  new_model_summary_df_learner$bh_pvalues_learner <- bh_adjusted_pvalues_learner

  # Arrange the data frame by the BH-adjusted p-values
  sorted_results <- arrange(new_model_summary_df_learner, bh_pvalues_props)

  print(sorted_results)
} else {
  cat("No clusters had sufficient variation in the learner variable to fit models.\n")
}

# Write the data frame to a CSV file
write.csv(new_model_summary_df_learner, file = "../../results/proportions_WTonly/intermed-tables/250301_rewardsbypropsandlearner_untransformed.csv")
```

## Scatterplots 
```{r fxn for scatterplots rewards by untrans props}
plot_cluster <- function(i, model_summary_df, new_merged_df) {
  # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_df[model_summary_df$cluster == i, ]

  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == i) %>%
    distinct()

  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$rewards,
    main = paste("Cluster", i),
    pch = 16, cex = 2,
    xlab = "Props_untrans", ylab = "Rewards",
    cex.lab = 1.5, cex.axis = 1.5,
    xlim = c(0, max(cluster_df$props_untrans)),
    cex.main = 2
  )

  # Fit lines for all data, male, and female
  fit_all <- lm(rewards ~ props_untrans, data = cluster_df)

  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)

  # Calculate R-squared value
  r2_all <- summary(fit_all)$r.squared

  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_adjusted_pvalues, digits = 3))
  )

  # Add legend
  legend("topleft",
    legend = legend_labels,
    col = c("black", "black", "black", "black"),
    lty = c(1, NA, NA, NA),
    cex = 1.2,
    bty = "n"
  )
}
```

```{r plot scatters rewards by untrans props}
# Get all unique cluster numbers
clusters <- unique(model_summary_sex_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("../../results/proportions_WTonly/RewardsbyProp_Figs", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("../../results/proportions_WTonly/RewardsbyProp_Figs/cluster_", cluster, "_plot.pdf"), width = 6, height = 8)

  # Create the plot
  plot_cluster(cluster, model_summary_df, new_merged_df)

  # Close the PDF device
  dev.off()

  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'RewardsbyProp_Figs' directory.\n")
```

### by Sex

```{r  fxn for scatterplots rewards by untrans props and sex}
plot_cluster_bysex <- function(i, model_summary_sex_df, new_merged_df) {
  # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_sex_df[model_summary_sex_df$cluster == i, ]

  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == i) %>%
    distinct()

  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$rewards,
    main = paste("Cluster", i),
    pch = 16, cex = 2,
    xlab = "Props_untrans", ylab = "Rewards",
    cex.lab = 1.5, cex.axis = 1.5,
    cex.main = 2,
    xlim = c(0, max(cluster_df$props_untrans)),
    col = ifelse(cluster_df$sex == "M", "#4478AB", "#ED6677")
  )

  # Fit lines for all data, male, and female
  fit_all <- lm(rewards ~ props_untrans, data = cluster_df)
  fit_male <- lm(rewards ~ props_untrans, data = cluster_df[cluster_df$sex == "M", ])
  fit_female <- lm(rewards ~ props_untrans, data = cluster_df[cluster_df$sex == "F", ])

  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)
  abline(fit_male, col = "#4478AB", lwd = 2)
  abline(fit_female, col = "#ED6677", lwd = 2)

  # Calculate R-squared values for each fit
  r2_all <- summary(fit_all)$r.squared
  r2_male <- summary(fit_male)$r.squared
  r2_female <- summary(fit_female)$r.squared

  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("Male (R =", round(r2_male, 3), ")"),
    paste("Female (R =", round(r2_female, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_pvalues_props, digits = 3))
  )

  # Add legend
  legend("topleft",
    legend = legend_labels,
    col = c("black", "#4478AB", "#ED6677", "black", "black", "black"),
    lty = c(1, 1, 1, NA, NA, NA),
    cex = 1.2,
    bty = "n"
  )
}
```

```{r plot scatters rewards by untrans props and sex}
# Get all unique cluster numbers
clusters <- unique(model_summary_sex_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("../../results/proportions_WTonly/RewardsbyProp_Figs", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("../../results/proportions_WTonly/RewardsbyProp_Figs/cluster_", cluster, "_plotwithSex.pdf"), width = 6, height = 8)

  # Create the plot
  plot_cluster_bysex(cluster, model_summary_sex_df, new_merged_df)

  # Close the PDF device
  dev.off()

  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'RewardsbyProp_Figs' directory.\n")
```

### by Learner

```{r  fxn for scatterplots rewards by untrans props and learner}
plot_cluster_bylearner <- function(i, model_summary_learner_df, new_merged_df) {
  # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_learner_df[model_summary_learner_df$cluster == i, ]

  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == i) %>%
    distinct()

  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$rewards,
    main = paste("Cluster", i),
    pch = 16, cex = 2,
    xlab = "Props_untrans", ylab = "Rewards",
    cex.lab = 1.5, cex.axis = 1.5,
    cex.main = 2,
    xlim = c(0, max(cluster_df$props_untrans)),
    col = ifelse(cluster_df$learner == "Learner", "#547B80", "#D1D3D4")
  )

  # Fit lines for all data, learner, and non_learner
  fit_all <- lm(rewards ~ props_untrans, data = cluster_df)
  fit_learner <- lm(rewards ~ props_untrans, data = cluster_df[cluster_df$learner == "Learner", ])
  fit_non_learner <- lm(rewards ~ props_untrans, data = cluster_df[cluster_df$learner == "Non_Learner", ])

  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)
  abline(fit_learner, col = "#547B80", lwd = 2)
  abline(fit_non_learner, col = "#D1D3D4", lwd = 2)

  # Calculate R-squared values for each fit
  r2_all <- summary(fit_all)$r.squared
  r2_learner <- summary(fit_learner)$r.squared
  r2_non_learner <- summary(fit_non_learner)$r.squared

  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("learner (R =", round(r2_learner, 3), ")"),
    paste("non_learner (R =", round(r2_non_learner, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_pvalues_props, digits = 3))
  )

  # Add legend
  legend("topleft",
    legend = legend_labels,
    col = c("black", "#547B80", "#D1D3D4", "black", "black", "black"),
    lty = c(1, 1, 1, NA, NA, NA),
    cex = 1.2,
    bty = "n"
  )
}
```

```{r plot scatters rewards by untrans props and learner}
# Get all unique cluster numbers
clusters <- unique(model_summary_learner_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("../../results/proportions_WTonly/RewardsbyProp_Figs/p", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("../../results/proportions_WTonly/RewardsbyProp_Figs/cluster_", cluster, "_plotwithLearner.pdf"), width = 6, height = 8)

  # Create the plot
  plot_cluster_bylearner(cluster, model_summary_learner_df, new_merged_df)

  # Close the PDF device
  dev.off()

  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'RewardsbyProp_Figs' directory.\n")
```

## Plotting B values
```{r plotting beta coefficients rewards}
# Assuming your data frame is called model_summary_df
p_beta <- ggplot(
  model_summary_df,
  aes(x = Props.props_trans, y = cluster)
) +
  geom_bar(
    stat = "identity",
    width = 0.7,
    fill = "#888888"
  ) +
  geom_errorbar(
    aes(
      xmin = Props.props_trans - Props.Std..Error,
      xmax = Props.props_trans + Props.Std..Error
    ),
    position = position_dodge(0.7),
    width = 0.2,
    size = 0.2
  ) +
  labs(
    x = "Beta Coefficient",
    y = "Cluster"
  ) +
  theme_classic() +
  theme(
    legend.position = "none",
    axis.text.y = element_text(color = rep(c("#000000", "#555555"),
      length.out = length(unique(model_summary_df$cluster))
    ))
  )

p_beta
ggsave("../../results/proportions_WTonly/intermed-figs/250301_rewardsbyprops_betacoeffs.pdf",
  device = pdf,
  width = 6,
  height = 8
)
```

```{r selecting sig clusters from rewards by props}
significant_clusters_rewards <- model_summary_df[model_summary_df$Props.p.value < 0.05, ]

significant_clusters_rewards_names <- sort(as.character(significant_clusters_rewards$cluster))
print(significant_clusters_rewards_names)
```

```{r merging sig clusters for rewards and learner}
merged_sig_clusters <- union(significant_cluster_names, significant_clusters_rewards_names)
merged_sig_clusters <- sort(as.character(merged_sig_clusters))
print(merged_sig_clusters)
```

```{r beta coefficient plot for merged sig clusters}
model_summary_df_filtered <- model_summary_df %>%
  filter(cluster %in% merged_sig_clusters)

# Set the factor levels to match the order in significant_cluster_names
model_summary_df_filtered$cluster <- factor(model_summary_df_filtered$cluster, levels = rev(merged_sig_clusters))

p_beta_sig <- ggplot(
  model_summary_df_filtered,
  aes(x = Props.props_trans, y = cluster)
) +
  geom_bar(
    stat = "identity",
    width = 0.7,
    fill = "#888888"
  ) +
  geom_errorbar(
    aes(
      xmin = Props.props_trans - Props.Std..Error,
      xmax = Props.props_trans + Props.Std..Error
    ),
    position = position_dodge(0.7),
    width = 0.2,
    size = 0.2
  ) +
  labs(
    x = "Beta Coefficient",
    y = ""
  ) +
  theme_classic() +
  theme(
    legend.position = "none",
    axis.text.y = element_blank()
  )

p_beta_sig
```


```{r cells and genes plot for sig clusters rewards and learner}
sig_cellsgenes_df <- cellsgenes_df %>%
  dplyr::filter(Cluster %in% merged_sig_clusters) %>%
  arrange(match(Cluster, merged_sig_clusters))

# Ensure Cluster is a factor with levels in the correct order
sig_cellsgenes_df$Cluster <- factor(sig_cellsgenes_df$Cluster, levels = rev(merged_sig_clusters))

cells <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = CellsPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = CellsPerCluster)) +
  scale_fill_gradient2(
    low = "#757575",
    mid = "#9E9E9E",
    high = "#FAFAFA",
    midpoint = 2000
  ) +
  ylab("") +
  xlab("Nuclei") +
  theme_classic() +
  scale_y_discrete(limits = rev(merged_sig_clusters)) +
  theme(
    axis.text.x = element_blank(),
    legend.position = "none",
    axis.text.y = element_text(color = rep(c("#000000", "#555555"),
      length.out = length(unique(calcnums$Cluster))
    ))
  )

genes <- ggplot(sig_cellsgenes_df, aes(x = 1, y = Cluster, fill = GenesPerCluster)) +
  geom_tile(color = "black", lwd = 0.1) +
  geom_text(aes(label = GenesPerCluster)) +
  scale_fill_gradient2(
    low = "#757575",
    mid = "#9E9E9E",
    high = "#FAFAFA",
    midpoint = 19000
  ) +
  ylab("") +
  xlab("Genes") +
  theme_classic() +
  scale_y_discrete(limits = rev(merged_sig_clusters)) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    legend.position = "none"
  )

wrap_plots(cells, genes)
```

```{r bar plot props by learner for merged sig clusters}
calcnums_filtered <- calcnums %>%
  filter(Cluster %in% merged_sig_clusters)

# Set the factor levels to match the order in significant_cluster_names
calcnums_filtered$Cluster <- factor(calcnums_filtered$Cluster, levels = rev(merged_sig_clusters))

merged_sig_p1 <- ggplot(calcnums_filtered, aes(x = mean_norm_count, y = Cluster, fill = Sac_Learner)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  geom_point(aes(x = norm_count, y = Cluster),
    position = position_dodge(width = 0.7),
    color = "black",
    size = 0.01
  ) +
  geom_errorbar(aes(y = Cluster, xmin = mean_norm_count - se_mean, xmax = mean_norm_count + se_mean),
    position = position_dodge(0.7),
    width = 0.2, size = 0.2
  ) +
  labs(x = "Proportion", y = "") +
  theme_classic() +
  scale_fill_manual(values = palette_learner) +
  theme(legend.position = "right") +
  theme(axis.text.y = element_blank())
merged_sig_p1
``` 

```{r save plot with beta coeffs and props by learner}
wrap_plots(cells, genes, merged_sig_p1, p_beta_sig, nrow = 1)

ggsave("../../results/proportions_WTonly/250301_propsbyLearnerandbetacoeffsforRewards_sigonly.pdf",
  device = pdf,
  width = 20,
  height = 4
)
```


## props diff. by Region
```{r add region to props df rewards}
model_summary_df$region <- anatomical_dict[model_summary_df$cluster]
model_summary_df <- model_summary_df %>%
  dplyr::arrange(region, bh_adjusted_pvalues)
model_summary_df <- model_summary_df[order(model_summary_df$region, model_summary_df$bh_adjusted_pvalues, decreasing = TRUE), ]
```

```{r p-values by region plot rewards}
n_clusters <- length(unique(model_summary_df$bh_adjusted_pvalues))
text_colors <- rep(c("#000000", "#555555"), length.out = n_clusters)

ggplot(model_summary_df, aes(
  x = -log10(bh_adjusted_pvalues),
  y = factor(cluster,
    levels = unique(model_summary_df$cluster)
  ),
  color = region
)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(
    x = "-log10(P-value)",
    y = "Cluster",
    title = "Differences in cluster proportions as predictors of rewards"
  ) +
  theme(
    axis.text.y = element_text(
      size = 8,
      color = rev(text_colors)
    ), # rev() to match the order of clusters
    legend.position = "right"
  )

ggsave(
  filename = "../../results/proportions_WTonly/intermed-figs/250301_rewardsprops_pvalues_hypovother.pdf",
  width = 12,
  height = 12,
  dpi = 300
)
```

```{r p-values by region plot rewards top 10}
filtered_model_summary_df <- model_summary_df %>%
  group_by(region) %>%
  arrange(bh_adjusted_pvalues) %>%
  slice_head(n = 10) %>%
  ungroup() %>%
  arrange(rev(region))

# Then use the filtered data in your plot
ggplot(filtered_model_summary_df, aes(
  x = -log10(bh_adjusted_pvalues),
  y = factor(cluster,
    levels = unique(filtered_model_summary_df$cluster)
  ),
  color = region
)) +
  geom_point(size = 3) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
  theme_minimal() +
  scale_color_manual(values = region_two_colors) +
  labs(
    x = "-log10(P-value)",
    y = "Cluster",
    title = "Differences in cluster proportions as predictors of rewards"
  ) +
  theme(
    axis.text.y = element_text(
      size = 8,
      color = rev(text_colors)[1:nrow(filtered_model_summary_df)]
    ), # adjust colors to match filtered data
    legend.position = "right",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.line.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.y = element_line(color = "black")
  )


ggsave(
  filename = "../../results/proportions_WTonly/250301_rewardsprops_pvalues_hypovother.pdf",
  width = 6,
  height = 8,
  dpi = 300
)
```

```{r Fisher's for rewards props significance by region}
# Create contingency table of significant vs non-significant clusters by region
model_summary_df$significant <- model_summary_df$bh_adjusted_pvalues < 0.05

# Create contingency table
cont_table <- with(model_summary_df, table(region, significant))

# Print the contingency table
print("Number of clusters by region and significance:")
print(cont_table)

# Run Fisher's exact test
fisher_result <- fisher.test(cont_table)

# Print results
print("\nFisher's exact test results:")
print(fisher_result)

# Calculate and print percentages for easier interpretation
percentages <- prop.table(cont_table, margin = 1) * 100 # margin=1 calculates percentages within each region
print("\nPercentage of significant clusters by region:")
print(percentages[, "TRUE"])
```

# Distance by Props
```{r linear regression distance by props}
# Create an empty data frame to store the results
model_summary_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Fit the linear regression model
  lm_model <- lm(distance ~ props_trans, data = cluster_df)

  # Extract the model summary
  model_summary <- summary(lm_model)

  # Create a named vector with model summary statistics
  model_summary_vec <- c(
    `(Intercept)` = coef(lm_model)[1],
    `(Intercept) p-value` = coef(model_summary)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model)[2],
    `Props Std. Error` = coef(model_summary)[2, "Std. Error"],
    `Props t value` = coef(model_summary)[2, "t value"],
    `Props p-value` = coef(model_summary)[2, "Pr(>|t|)"],
    r_squared = model_summary$r.squared,
    adj_r_squared = model_summary$adj.r.squared,
    f_statistic = model_summary$fstatistic[1],
    f_pvalue = pf(model_summary$fstatistic[1], model_summary$fstatistic[2], model_summary$fstatistic[3], lower.tail = FALSE)
  )

  # Convert the named vector to a data frame
  model_summary_vec_df <- data.frame(t(model_summary_vec))

  # Add a column for the cluster
  model_summary_vec_df$cluster <- cluster

  # Append the data frame to the overall result
  model_summary_df <- rbind(model_summary_df, model_summary_vec_df)
}

# Extract the 'Props p-value' column
props_pvalues <- model_summary_df$Props.p.value

# Perform BH adjustment
bh_adjusted_pvalues <- p.adjust(props_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
model_summary_df$bh_pvalues_props <- bh_adjusted_pvalues

model_summary_df %>%
  ungroup() %>%
  arrange(bh_pvalues_props)

# Print the resulting data frame
model_summary_df

write.csv(model_summary_df, file = "../../results/proportions_WTonly/250301_distancebyprops.csv")
```

## . with Sex
```{r linear regression distance by props and sex}
# Modified to handle clusters with only one level for sex
# Create an empty data frame to store the results
model_summary_sex_df <- data.frame()

# Loop over each cluster
for (cluster in unique(merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Check if the cluster has more than one sex level
  if (n_distinct(cluster_df$sex) > 1) {
    # Fit the linear regression model with sex added
    tryCatch(
      {
        lm_model_sex <- lm(distance ~ props_trans + sex, data = cluster_df)

        # Extract the model summary
        model_summary_sex <- summary(lm_model_sex)

        # Create a named vector with model summary statistics
        model_summary_vec_sex <- c(
          `(Intercept)` = coef(lm_model_sex)[1],
          `(Intercept) p-value` = coef(model_summary_sex)[1, "Pr(>|t|)"],
          `Props` = coef(lm_model_sex)[2],
          `Props Std. Error` = coef(model_summary_sex)[2, "Std. Error"],
          `Props t value` = coef(model_summary_sex)[2, "t value"],
          `Props p-value` = coef(model_summary_sex)[2, "Pr(>|t|)"],
          `Sex` = coef(lm_model_sex)[3],
          `Sex Std. Error` = coef(model_summary_sex)[3, "Std. Error"],
          `Sex t value` = coef(model_summary_sex)[3, "t value"],
          `Sex p-value` = coef(model_summary_sex)[3, "Pr(>|t|)"],
          r_squared = model_summary_sex$r.squared,
          adj_r_squared = model_summary_sex$adj.r.squared,
          f_statistic = model_summary_sex$fstatistic[1],
          f_pvalue = pf(model_summary_sex$fstatistic[1], model_summary_sex$fstatistic[2], model_summary_sex$fstatistic[3], lower.tail = FALSE)
        )

        # Convert the named vector to a data frame
        model_summary_vec_sex_df <- data.frame(t(model_summary_vec_sex))

        # Add a column for the cluster
        model_summary_vec_sex_df$cluster <- cluster

        # Append the data frame to the overall result
        model_summary_sex_df <- rbind(model_summary_sex_df, model_summary_vec_sex_df)
      },
      error = function(e) {
        # If an error occurs, print it and continue
        cat("Error in cluster", cluster, ":", e$message, "\n")
      }
    )
  } else {
    # Print a message for clusters with only one sex level
    cat("Skipping cluster '", cluster, "' - only one sex level present\n", sep = "")
  }
}

# If there are results to process
if (nrow(model_summary_sex_df) > 0) {
  # Extract the 'Props p-value' column
  props_pvalues <- model_summary_sex_df$Props.p.value
  sex_pvalues <- model_summary_sex_df$Sex.p.value

  # Perform BH adjustment
  bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
  bh_adjusted_pvalues_sex <- p.adjust(sex_pvalues, method = "BH")

  # Add the BH-adjusted p-values to the data frame
  model_summary_sex_df$bh_pvalues_props <- bh_adjusted_pvalues_props
  model_summary_sex_df$bh_pvalues_sex <- bh_adjusted_pvalues_sex

  # Sort and print the results
  sorted_results <- model_summary_sex_df %>%
    ungroup() %>%
    arrange(bh_pvalues_props)

  print(sorted_results)
} else {
  cat("No clusters had sufficient variation in the sex variable to fit models.\n")
}
# Print the resulting data frame
model_summary_sex_df

# Write the data frame to a CSV file
write.csv(model_summary_sex_df, file = "../../results/proportions_WTonly/250301_distancebyprops_sex.csv")
```

## Untransformed props
Checking to see that transforming the proportions (per propeller) isn't changing 
the results, and getting untransformed props for plotting.

```{r linear regression distance by untransformed props}
# Create an empty data frame to store the results
new_model_summary_df <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Fit the linear regression model
  lm_model <- lm(distance ~ props_untrans, data = cluster_df)

  # Extract the model summary
  new_model_summary <- summary(lm_model)

  # Create a named vector with model summary statistics
  new_model_summary_vec <- c(
    `(Intercept)` = coef(lm_model)[1],
    `(Intercept) p-value` = coef(new_model_summary)[1, "Pr(>|t|)"],
    `Props` = coef(lm_model)[2],
    `Props Std. Error` = coef(new_model_summary)[2, "Std. Error"],
    `Props t value` = coef(new_model_summary)[2, "t value"],
    `Props p-value` = coef(new_model_summary)[2, "Pr(>|t|)"],
    r_squared = new_model_summary$r.squared,
    adj_r_squared = new_model_summary$adj.r.squared,
    f_statistic = new_model_summary$fstatistic[1],
    f_pvalue = pf(new_model_summary$fstatistic[1], new_model_summary$fstatistic[2], new_model_summary$fstatistic[3], lower.tail = FALSE)
  )

  # Convert the named vector to a data frame
  new_model_summary_vec_df <- data.frame(t(new_model_summary_vec))

  # Add a column for the cluster
  new_model_summary_vec_df$cluster <- cluster

  # Append the data frame to the overall result
  new_model_summary_df <- rbind(new_model_summary_df, new_model_summary_vec_df)
}

# Extract the 'Props p-value' column
props_pvalues <- new_model_summary_df$Props.p.value

# Perform BH adjustment
bh_adjusted_pvalues <- p.adjust(props_pvalues, method = "BH")

# Add the BH-adjusted p-values to the data frame
new_model_summary_df$bh_adjusted_pvalues <- bh_adjusted_pvalues

arrange(new_model_summary_df, new_model_summary_df$bh_adjusted_pvalues)

# Print the resulting data frame
new_model_summary_df

write.csv(new_model_summary_df, file = "../../results/proportions_WTonly/intermed-tables/250301_distancebyprops_untransformed.csv")
```

```{r linear regression distance by untransformed props and sex}
# Modified to handle clusters with only one level of sex
# Create an empty data frame to store the results
new_model_summary_df_sex <- data.frame()

# Loop over each cluster
for (cluster in unique(new_merged_df$clusters)) {
  # Filter the data frame for the current cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == cluster) %>%
    distinct()

  # Check if the cluster has more than one sex level
  if (n_distinct(cluster_df$sex) > 1) {
    # Fit the linear regression model with sex added
    tryCatch(
      {
        lm_model_sex <- lm(distance ~ props_untrans + sex, data = cluster_df)

        # Extract the model summary
        new_model_summary_sex <- summary(lm_model_sex)

        # Create a named vector with model summary statistics
        new_model_summary_vec_sex <- c(
          `(Intercept)` = coef(lm_model_sex)[1],
          `(Intercept) p-value` = coef(new_model_summary_sex)[1, "Pr(>|t|)"],
          `Props` = coef(lm_model_sex)[2],
          `Props Std. Error` = coef(new_model_summary_sex)[2, "Std. Error"],
          `Props t value` = coef(new_model_summary_sex)[2, "t value"],
          `Props p-value` = coef(new_model_summary_sex)[2, "Pr(>|t|)"],
          `Sex` = coef(lm_model_sex)[3],
          `Sex Std. Error` = coef(new_model_summary_sex)[3, "Std. Error"],
          `Sex t value` = coef(new_model_summary_sex)[3, "t value"],
          `Sex p-value` = coef(new_model_summary_sex)[3, "Pr(>|t|)"],
          r_squared = new_model_summary_sex$r.squared,
          adj_r_squared = new_model_summary_sex$adj.r.squared,
          f_statistic = new_model_summary_sex$fstatistic[1],
          f_pvalue = pf(new_model_summary_sex$fstatistic[1], new_model_summary_sex$fstatistic[2], new_model_summary_sex$fstatistic[3], lower.tail = FALSE)
        )

        # Convert the named vector to a data frame
        new_model_summary_vec_sex_df <- data.frame(t(new_model_summary_vec_sex))

        # Add a column for the cluster
        new_model_summary_vec_sex_df$cluster <- cluster

        # Append the data frame to the overall result
        new_model_summary_df_sex <- rbind(new_model_summary_df_sex, new_model_summary_vec_sex_df)
      },
      error = function(e) {
        # If an error occurs, print it and continue
        cat("Error in cluster", cluster, ":", e$message, "\n")
      }
    )
  } else {
    # Print a message for clusters with only one sex level
    cat("Skipping cluster '", cluster, "' - only one sex level present\n", sep = "")
  }
}

# If there are results to process
if (nrow(new_model_summary_df_sex) > 0) {
  # Extract the 'Props p-value' column
  props_pvalues <- new_model_summary_df_sex$Props.p.value
  sex_pvalues <- new_model_summary_df_sex$Sex.p.value

  # Perform BH adjustment
  bh_adjusted_pvalues_props <- p.adjust(props_pvalues, method = "BH")
  bh_adjusted_pvalues_sex <- p.adjust(sex_pvalues, method = "BH")

  # Add the BH-adjusted p-values to the data frame
  new_model_summary_df_sex$bh_pvalues_props <- bh_adjusted_pvalues_props
  new_model_summary_df_sex$bh_pvalues_sex <- bh_adjusted_pvalues_sex

  # Arrange the data frame by the BH-adjusted p-values
  sorted_results <- arrange(new_model_summary_df_sex, bh_pvalues_props)

  print(sorted_results)
} else {
  cat("No clusters had sufficient variation in the sex variable to fit models.\n")
}
# Print the resulting data frame
new_model_summary_df_sex

# Write the data frame to a CSV file
write.csv(new_model_summary_df_sex, file = "../../results/proportions_WTonly/intermed-tables/250301_distancebypropsandsex_untransformed.csv")
```

## Scatterplots 
```{r fxn for scatterplots distance by untrans props}
plot_cluster <- function(i, model_summary_df, new_merged_df) {
  # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_df[model_summary_df$cluster == i, ]

  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == i) %>%
    distinct()

  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$distance,
    main = paste("Cluster", i),
    pch = 16, cex = 2,
    xlab = "Props_untrans", ylab = "distance",
    cex.lab = 1.5, cex.axis = 1.5,
    xlim = c(0, max(cluster_df$props_untrans)),
    cex.main = 2
  )

  # Fit lines for all data, male, and female
  fit_all <- lm(distance ~ props_untrans, data = cluster_df)

  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)

  # Calculate R-squared value
  r2_all <- summary(fit_all)$r.squared

  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_adjusted_pvalues, digits = 3))
  )

  # Add legend
  legend("topleft",
    legend = legend_labels,
    col = c("black", "black", "black", "black"),
    lty = c(1, NA, NA, NA),
    cex = 1.2,
    bty = "n"
  )
}
```

```{r plot scatters distance by untrans props}
# Get all unique cluster numbers
clusters <- unique(model_summary_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("../../results/proportions_WTonly/DistancebyProp_Figs", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("../../results/proportions_WTonly/DistancebyProp_Figs/cluster_", cluster, "_plot.pdf"), width = 6, height = 8)

  # Create the plot
  plot_cluster(cluster, model_summary_df, new_merged_df)

  # Close the PDF device
  dev.off()

  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'DistancebyProp_Figs' directory.\n")
```

### by Sex

```{r  fxn for scatterplots distance by untrans props and sex}
plot_cluster_bysex <- function(i, model_summary_sex_df, new_merged_df) {
  # Extract the results for the specific cluster we're plotting
  cluster_results <- model_summary_sex_df[model_summary_sex_df$cluster == i, ]

  # Filter the data for the specific cluster
  cluster_df <- new_merged_df %>%
    filter(clusters == i) %>%
    distinct()

  # Create the plot with untransformed data
  plot(cluster_df$props_untrans, cluster_df$distance,
    main = paste("Cluster", i),
    pch = 16, cex = 2,
    xlab = "Props_untrans", ylab = "Distance",
    cex.lab = 1.5, cex.axis = 1.5,
    cex.main = 2,
    xlim = c(0, max(cluster_df$props_untrans)),
    col = ifelse(cluster_df$sex == "M", "#4478AB", "#ED6677")
  )

  # Fit lines for all data, male, and female
  fit_all <- lm(distance ~ props_untrans, data = cluster_df)
  fit_male <- lm(distance ~ props_untrans, data = cluster_df[cluster_df$sex == "M", ])
  fit_female <- lm(distance ~ props_untrans, data = cluster_df[cluster_df$sex == "F", ])

  # Add the fit lines
  abline(fit_all, col = "black", lwd = 2)
  abline(fit_male, col = "#4478AB", lwd = 2)
  abline(fit_female, col = "#ED6677", lwd = 2)

  # Calculate R-squared values for each fit
  r2_all <- summary(fit_all)$r.squared
  r2_male <- summary(fit_male)$r.squared
  r2_female <- summary(fit_female)$r.squared

  # Create legend labels with statistics
  legend_labels <- c(
    paste("All (R =", round(r2_all, 3), ")"),
    paste("Male (R =", round(r2_male, 3), ")"),
    paste("Female (R =", round(r2_female, 3), ")"),
    paste("Model Adj. R =", round(cluster_results$adj_r_squared, 3)),
    paste("Props p-value =", format.pval(cluster_results$Props.p.value, digits = 3)),
    paste("BH Adj. p-value =", format.pval(cluster_results$bh_pvalues_props, digits = 3))
  )

  # Add legend
  legend("topleft",
    legend = legend_labels,
    col = c("black", "#4478AB", "#ED6677", "black", "black", "black"),
    lty = c(1, 1, 1, NA, NA, NA),
    cex = 1.2,
    bty = "n"
  )
}
```

```{r plot scatters distance by untrans props and sex}
# Get all unique cluster numbers
clusters <- unique(model_summary_sex_df$cluster)

# Create a directory to save the PDFs if it doesn't exist
dir.create("../../results/proportions_WTonly/DistancebyProp_Figs", showWarnings = FALSE)

# Iterate through clusters
for (cluster in clusters) {
  # Open a PDF device
  pdf(file = paste0("../../results/proportions_WTonly/DistancebyProp_Figs/cluster_", cluster, "_plotwithSex.pdf"), width = 6, height = 8)

  # Create the plot
  plot_cluster_bysex(cluster, model_summary_sex_df, new_merged_df)

  # Close the PDF device
  dev.off()

  # Print progress
  cat("Saved plot for cluster", cluster, "\n")
}

cat("All plots have been saved in the 'DistancebyProp' directory.\n")
```

# Lisi score

```{r lisi score tables}
md <- data.frame(
  sample <- wt_only$sample,
  sex <- wt_only$sex,
  celltype <- wt_only$cell_type
)
colnames(md) <- c("sample", "sex", "celltype")


table(md$sex)

table(md$sample)
```

```{r compute lisi scores}
res <- compute_lisi(Embeddings(wt_only, reduction = "umap"), md,
  perplexity = 200,
  c("sample", "sex")
)
```

```{r mean lisi for sex}
sex_mean <- mean(res$sex, na.rm = TRUE)
sex_mean
```


```{r lisi figure sex, fig.height = 2}
ggplot(res, aes(x = sex)) +
  # geom_histogram(binwidth = 0.01, fill = "grey") +
  geom_density(fill = "#bababa") +
  geom_vline(
    xintercept = median(res$sex),
    linetype = 3
  ) +
  xlim(1, 2) +
  theme_classic()

ggsave("../../results/proportions_WTonly/250301_lisi_sex.pdf",
  device = pdf,
  width = 5,
  height = 3
)
```

# End
